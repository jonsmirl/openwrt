Bottom: bc0bd94ba41e16394fd53c4d11863fa354b9afa3
Top:    7434181e1760631d2de50fd4381ffd51b6fc8c38
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2013-12-31 17:21:45 -0500

Initial framework for Zarlink


---

diff --git a/.gitignore b/.gitignore
index 70a454c..1806af2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,4 +21,6 @@
 .#*
 *#
 .emacs.desktop*
-TAGS*~
\ No newline at end of file
+TAGS*~
+Packages
+Packages.gz
diff --git a/target/linux/ramips/dts/ZARLINK.dts b/target/linux/ramips/dts/ZARLINK.dts
new file mode 100644
index 0000000..d38ed07
--- /dev/null
+++ b/target/linux/ramips/dts/ZARLINK.dts
@@ -0,0 +1,88 @@
+/include/ "rt5350.dtsi"
+
+/ {
+	compatible = "ZARLINK", "ralink,rt5350-soc";
+	model = "ReliableTV Zarlink";
+
+	palmbus@10000000 {
+		spi@b00 {
+			status = "okay";
+			m25p80@0 {
+				compatible = "mx25l6405d";
+				linux,modalias = "m25p80", "mx25l6405d";
+
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0 0>;
+				spi-max-frequency = <10000000>;
+
+				partition@0 {
+					label = "u-boot";
+					reg = <0x0 0x30000>;
+					read-only;
+				};
+
+				partition@30000 {
+					label = "u-boot-env";
+					reg = <0x30000 0x10000>;
+					read-only;
+				};
+
+				factory: partition@40000 {
+					label = "factory";
+					reg = <0x40000 0x10000>;
+					read-only;
+				};
+
+				partition@50000 {
+					label = "firmware";
+					reg = <0x50000 0x1fb0000>;
+				};
+			};
+
+			codec: le89156@1 {
+				compatible = "zarlink,le89156";
+				reg = <0 0>;
+				spi-max-frequency = <10000000>;
+			};
+		};
+	};
+
+	sound {
+		compatible = "ralink,le89156-audio";
+		controller = <&pcm>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT";
+		mux-int-port = <1>;
+		mux-ext-port = <4>;
+	};
+
+
+	pinctrl {
+		state_default: pinctrl0 {
+			gpio {
+				ralink,group = "i2c", "jtag";
+				ralink,function = "gpio";
+			};
+			uartf {
+				ralink,group = "uartf";
+				ralink,function = "pcm gpio";
+			};
+		};
+	};
+
+	esw@10110000 {
+		ralink,portmap = <0x3f>;
+	};
+
+	ehci@101c0000 {
+		status = "okay";
+	};
+
+	ohci@101c1000 {
+		status = "okay";
+	};
+};
diff --git a/target/linux/ramips/dts/rt5350.dtsi b/target/linux/ramips/dts/rt5350.dtsi
index cb9077f..5487669 100644
--- a/target/linux/ramips/dts/rt5350.dtsi
+++ b/target/linux/ramips/dts/rt5350.dtsi
@@ -205,6 +205,22 @@
 			interrupt-parent = <&cpuintc>;
 			interrupts = <7>;
 		};
+
+		pcm@2000 {
+			compatible = "ralink,rt5350-pcm";
+			reg = <0x2000 0x100>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <4>;
+		}
+
+		gdma@2800 {
+			compatible = "ralink,rt5350-gdma", "ralink,rt2880-gdma";
+			reg = <0x2800 0x100>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <7>;
+		}
 	};
 
 	pinctrl {
diff --git a/target/linux/ramips/image/Makefile b/target/linux/ramips/image/Makefile
index 2d4395d..6e605ad 100644
--- a/target/linux/ramips/image/Makefile
+++ b/target/linux/ramips/image/Makefile
@@ -514,6 +514,8 @@ Image/Build/Profile/X8=$(call BuildFirmware/Poray8M/$(1),$(1),x8,X8)
 
 Image/Build/Profile/XDXRN502J=$(call BuildFirmware/Default4M/$(1),$(1),xdxrn502j,XDXRN502J)
 
+Image/Build/Profile/ZARLINK=$(call BuildFirmware/Default8M/$(1),$(1),zarlink,ZARLINK)
+
 ifeq ($(SUBTARGET),rt305x)
 define Image/Build/Profile/Default
 	$(call Image/Build/Profile/3G6200N,$(1))
@@ -583,6 +585,7 @@ define Image/Build/Profile/Default
 	$(call Image/Build/Profile/X5,$(1))
 	$(call Image/Build/Profile/X8,$(1))
 	$(call Image/Build/Profile/XDXRN502J,$(1))
+	$(call Image/Build/Profile/ZARLINK,$(1))
 endef
 endif
 
diff --git a/target/linux/ramips/patches-3.10/0123-rt5350-feature.patch b/target/linux/ramips/patches-3.10/0123-rt5350-feature.patch
new file mode 100644
index 0000000..3544f6b
--- /dev/null
+++ b/target/linux/ramips/patches-3.10/0123-rt5350-feature.patch
@@ -0,0 +1,14 @@
+--- a/drivers/net/ethernet/ralink/ralink_soc_eth.c
++++ b/drivers/net/ethernet/ralink/ralink_soc_eth.c
+@@ -740,10 +740,9 @@ static int fe_probe(struct platform_devi
+ 	if (soc->tso) {
+ 		dev_info(&pdev->dev, "Enabling TSO\n");
+ 		netdev->features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_IPV6_CSUM;
++		netdev->hw_features = netdev->vlan_features = netdev->features;
+ 	}
+ 
+-	netdev->hw_features = netdev->vlan_features = netdev->features;
+-
+ 	netdev->irq = platform_get_irq(pdev, 0);
+ 	if (netdev->irq < 0) {
+ 		dev_err(&pdev->dev, "no IRQ resource found\n");
diff --git a/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch b/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
new file mode 100644
index 0000000..3cc7882
--- /dev/null
+++ b/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
@@ -0,0 +1,1858 @@
+--- /dev/null
++++ b/sound/soc/codecs/le89156.c
+@@ -0,0 +1,1101 @@
++/*
++ * le89156.c  --  LE89156 ALSA SoC Audio driver
++ *
++ * Copyright 2007-11 Wolfson Microelectronics, plc
++ *
++ * Author: Liam Girdwood
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/pm.h>
++#include <linux/i2c.h>
++#include <linux/slab.h>
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++#include <sound/initval.h>
++#include <sound/tlv.h>
++#include <sound/le89156.h>
++
++#include "le89156.h"
++
++/* R25 - Power 1 */
++#define LE89156_VMID_MASK 0x180
++#define LE89156_VREF      0x40
++
++/* R26 - Power 2 */
++#define LE89156_PWR2_LOUT1	0x40
++#define LE89156_PWR2_ROUT1	0x20
++#define LE89156_PWR2_OUT3	0x02
++
++/* R28 - Anti-pop 1 */
++#define LE89156_POBCTRL   0x80
++#define LE89156_BUFDCOPEN 0x10
++#define LE89156_BUFIOEN   0x08
++#define LE89156_SOFT_ST   0x04
++#define LE89156_HPSTBY    0x01
++
++/* R29 - Anti-pop 2 */
++#define LE89156_DISOP     0x40
++#define LE89156_DRES_MASK 0x30
++
++/*
++ * le89156 register cache
++ * We can't read the LE89156 register space when we are
++ * using 2 wire for device control, so we cache them instead.
++ */
++static const struct reg_default le89156_reg_defaults[] = {
++	{  0x0, 0x00a7 },
++	{  0x1, 0x00a7 },
++	{  0x2, 0x0000 },
++	{  0x3, 0x0000 },
++	{  0x4, 0x0000 },
++	{  0x5, 0x0008 },
++	{  0x6, 0x0000 },
++	{  0x7, 0x000a },
++	{  0x8, 0x01c0 },
++	{  0x9, 0x0000 },
++	{  0xa, 0x00ff },
++	{  0xb, 0x00ff },
++
++	{ 0x10, 0x0000 },
++	{ 0x11, 0x007b },
++	{ 0x12, 0x0100 },
++	{ 0x13, 0x0032 },
++	{ 0x14, 0x0000 },
++	{ 0x15, 0x00c3 },
++	{ 0x16, 0x00c3 },
++	{ 0x17, 0x01c0 },
++	{ 0x18, 0x0000 },
++	{ 0x19, 0x0000 },
++	{ 0x1a, 0x0000 },
++	{ 0x1b, 0x0000 },
++	{ 0x1c, 0x0000 },
++	{ 0x1d, 0x0000 },
++
++	{ 0x20, 0x0100 },
++	{ 0x21, 0x0100 },
++	{ 0x22, 0x0050 },
++
++	{ 0x25, 0x0050 },
++	{ 0x26, 0x0000 },
++	{ 0x27, 0x0000 },
++	{ 0x28, 0x0000 },
++	{ 0x29, 0x0000 },
++	{ 0x2a, 0x0040 },
++	{ 0x2b, 0x0000 },
++	{ 0x2c, 0x0000 },
++	{ 0x2d, 0x0050 },
++	{ 0x2e, 0x0050 },
++	{ 0x2f, 0x0000 },
++	{ 0x30, 0x0002 },
++	{ 0x31, 0x0037 },
++
++	{ 0x33, 0x0080 },
++	{ 0x34, 0x0008 },
++	{ 0x35, 0x0031 },
++	{ 0x36, 0x0026 },
++	{ 0x37, 0x00e9 },
++};
++
++static bool le89156_volatile(struct device *dev, unsigned int reg)
++{
++	switch (reg) {
++	case LE89156_RESET:
++		return true;
++	default:
++		return false;
++	}
++}
++
++struct le89156_priv {
++	struct regmap *regmap;
++	int (*set_bias_level)(struct snd_soc_codec *,
++			      enum snd_soc_bias_level level);
++	struct snd_soc_dapm_widget *lout1;
++	struct snd_soc_dapm_widget *rout1;
++	struct snd_soc_dapm_widget *out3;
++	bool deemph;
++	int playback_fs;
++};
++
++#define le89156_reset(c)	snd_soc_write(c, LE89156_RESET, 0)
++
++/* enumerated controls */
++static const char *le89156_polarity[] = {"No Inversion", "Left Inverted",
++	"Right Inverted", "Stereo Inversion"};
++static const char *le89156_3d_upper_cutoff[] = {"High", "Low"};
++static const char *le89156_3d_lower_cutoff[] = {"Low", "High"};
++static const char *le89156_alcfunc[] = {"Off", "Right", "Left", "Stereo"};
++static const char *le89156_alcmode[] = {"ALC", "Limiter"};
++
++static const struct soc_enum le89156_enum[] = {
++	SOC_ENUM_SINGLE(LE89156_DACCTL1, 5, 4, le89156_polarity),
++	SOC_ENUM_SINGLE(LE89156_DACCTL2, 5, 4, le89156_polarity),
++	SOC_ENUM_SINGLE(LE89156_3D, 6, 2, le89156_3d_upper_cutoff),
++	SOC_ENUM_SINGLE(LE89156_3D, 5, 2, le89156_3d_lower_cutoff),
++	SOC_ENUM_SINGLE(LE89156_ALC1, 7, 4, le89156_alcfunc),
++	SOC_ENUM_SINGLE(LE89156_ALC3, 8, 2, le89156_alcmode),
++};
++
++static const int deemph_settings[] = { 0, 32000, 44100, 48000 };
++
++static int le89156_set_deemph(struct snd_soc_codec *codec)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	int val, i, best;
++
++	/* If we're using deemphasis select the nearest available sample
++	 * rate.
++	 */
++	if (le89156->deemph) {
++		best = 1;
++		for (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {
++			if (abs(deemph_settings[i] - le89156->playback_fs) <
++			    abs(deemph_settings[best] - le89156->playback_fs))
++				best = i;
++		}
++
++		val = best << 1;
++	} else {
++		val = 0;
++	}
++
++	dev_dbg(codec->dev, "Set deemphasis %d\n", val);
++
++	return snd_soc_update_bits(codec, LE89156_DACCTL1,
++				   0x6, val);
++}
++
++static int le89156_get_deemph(struct snd_kcontrol *kcontrol,
++			     struct snd_ctl_elem_value *ucontrol)
++{
++	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++
++	ucontrol->value.enumerated.item[0] = le89156->deemph;
++	return 0;
++}
++
++static int le89156_put_deemph(struct snd_kcontrol *kcontrol,
++			     struct snd_ctl_elem_value *ucontrol)
++{
++	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	int deemph = ucontrol->value.enumerated.item[0];
++
++	if (deemph > 1)
++		return -EINVAL;
++
++	le89156->deemph = deemph;
++
++	return le89156_set_deemph(codec);
++}
++
++static const DECLARE_TLV_DB_SCALE(adc_tlv, -9700, 50, 0);
++static const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 50, 1);
++static const DECLARE_TLV_DB_SCALE(bypass_tlv, -2100, 300, 0);
++static const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);
++static const DECLARE_TLV_DB_SCALE(boost_tlv, -1200, 300, 1);
++
++static const struct snd_kcontrol_new le89156_snd_controls[] = {
++SOC_DOUBLE_R_TLV("Capture Volume", LE89156_LINVOL, LE89156_RINVOL,
++		 0, 63, 0, adc_tlv),
++SOC_DOUBLE_R("Capture Volume ZC Switch", LE89156_LINVOL, LE89156_RINVOL,
++	6, 1, 0),
++SOC_DOUBLE_R("Capture Switch", LE89156_LINVOL, LE89156_RINVOL,
++	7, 1, 0),
++
++SOC_SINGLE_TLV("Right Input Boost Mixer RINPUT3 Volume",
++	       LE89156_INBMIX1, 4, 7, 0, boost_tlv),
++SOC_SINGLE_TLV("Right Input Boost Mixer RINPUT2 Volume",
++	       LE89156_INBMIX1, 1, 7, 0, boost_tlv),
++SOC_SINGLE_TLV("Left Input Boost Mixer LINPUT3 Volume",
++	       LE89156_INBMIX2, 4, 7, 0, boost_tlv),
++SOC_SINGLE_TLV("Left Input Boost Mixer LINPUT2 Volume",
++	       LE89156_INBMIX2, 1, 7, 0, boost_tlv),
++
++SOC_DOUBLE_R_TLV("Playback Volume", LE89156_LDAC, LE89156_RDAC,
++		 0, 255, 0, dac_tlv),
++
++SOC_DOUBLE_R_TLV("Headphone Playback Volume", LE89156_LOUT1, LE89156_ROUT1,
++		 0, 127, 0, out_tlv),
++SOC_DOUBLE_R("Headphone Playback ZC Switch", LE89156_LOUT1, LE89156_ROUT1,
++	7, 1, 0),
++
++SOC_DOUBLE_R_TLV("Speaker Playback Volume", LE89156_LOUT2, LE89156_ROUT2,
++		 0, 127, 0, out_tlv),
++SOC_DOUBLE_R("Speaker Playback ZC Switch", LE89156_LOUT2, LE89156_ROUT2,
++	7, 1, 0),
++SOC_SINGLE("Speaker DC Volume", LE89156_CLASSD3, 3, 5, 0),
++SOC_SINGLE("Speaker AC Volume", LE89156_CLASSD3, 0, 5, 0),
++
++SOC_SINGLE("PCM Playback -6dB Switch", LE89156_DACCTL1, 7, 1, 0),
++SOC_ENUM("ADC Polarity", le89156_enum[0]),
++SOC_SINGLE("ADC High Pass Filter Switch", LE89156_DACCTL1, 0, 1, 0),
++
++SOC_ENUM("DAC Polarity", le89156_enum[2]),
++SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
++		    le89156_get_deemph, le89156_put_deemph),
++
++SOC_ENUM("3D Filter Upper Cut-Off", le89156_enum[2]),
++SOC_ENUM("3D Filter Lower Cut-Off", le89156_enum[3]),
++SOC_SINGLE("3D Volume", LE89156_3D, 1, 15, 0),
++SOC_SINGLE("3D Switch", LE89156_3D, 0, 1, 0),
++
++SOC_ENUM("ALC Function", le89156_enum[4]),
++SOC_SINGLE("ALC Max Gain", LE89156_ALC1, 4, 7, 0),
++SOC_SINGLE("ALC Target", LE89156_ALC1, 0, 15, 1),
++SOC_SINGLE("ALC Min Gain", LE89156_ALC2, 4, 7, 0),
++SOC_SINGLE("ALC Hold Time", LE89156_ALC2, 0, 15, 0),
++SOC_ENUM("ALC Mode", le89156_enum[5]),
++SOC_SINGLE("ALC Decay", LE89156_ALC3, 4, 15, 0),
++SOC_SINGLE("ALC Attack", LE89156_ALC3, 0, 15, 0),
++
++SOC_SINGLE("Noise Gate Threshold", LE89156_NOISEG, 3, 31, 0),
++SOC_SINGLE("Noise Gate Switch", LE89156_NOISEG, 0, 1, 0),
++
++SOC_DOUBLE_R("ADC PCM Capture Volume", LE89156_LINPATH, LE89156_RINPATH,
++	0, 127, 0),
++
++SOC_SINGLE_TLV("Left Output Mixer Boost Bypass Volume",
++	       LE89156_BYPASS1, 4, 7, 1, bypass_tlv),
++SOC_SINGLE_TLV("Left Output Mixer LINPUT3 Volume",
++	       LE89156_LOUTMIX, 4, 7, 1, bypass_tlv),
++SOC_SINGLE_TLV("Right Output Mixer Boost Bypass Volume",
++	       LE89156_BYPASS2, 4, 7, 1, bypass_tlv),
++SOC_SINGLE_TLV("Right Output Mixer RINPUT3 Volume",
++	       LE89156_ROUTMIX, 4, 7, 1, bypass_tlv),
++};
++
++static const struct snd_kcontrol_new le89156_lin_boost[] = {
++SOC_DAPM_SINGLE("LINPUT2 Switch", LE89156_LINPATH, 6, 1, 0),
++SOC_DAPM_SINGLE("LINPUT3 Switch", LE89156_LINPATH, 7, 1, 0),
++SOC_DAPM_SINGLE("LINPUT1 Switch", LE89156_LINPATH, 8, 1, 0),
++};
++
++static const struct snd_kcontrol_new le89156_lin[] = {
++SOC_DAPM_SINGLE("Boost Switch", LE89156_LINPATH, 3, 1, 0),
++};
++
++static const struct snd_kcontrol_new le89156_rin_boost[] = {
++SOC_DAPM_SINGLE("RINPUT2 Switch", LE89156_RINPATH, 6, 1, 0),
++SOC_DAPM_SINGLE("RINPUT3 Switch", LE89156_RINPATH, 7, 1, 0),
++SOC_DAPM_SINGLE("RINPUT1 Switch", LE89156_RINPATH, 8, 1, 0),
++};
++
++static const struct snd_kcontrol_new le89156_rin[] = {
++SOC_DAPM_SINGLE("Boost Switch", LE89156_RINPATH, 3, 1, 0),
++};
++
++static const struct snd_kcontrol_new le89156_loutput_mixer[] = {
++SOC_DAPM_SINGLE("PCM Playback Switch", LE89156_LOUTMIX, 8, 1, 0),
++SOC_DAPM_SINGLE("LINPUT3 Switch", LE89156_LOUTMIX, 7, 1, 0),
++SOC_DAPM_SINGLE("Boost Bypass Switch", LE89156_BYPASS1, 7, 1, 0),
++};
++
++static const struct snd_kcontrol_new le89156_routput_mixer[] = {
++SOC_DAPM_SINGLE("PCM Playback Switch", LE89156_ROUTMIX, 8, 1, 0),
++SOC_DAPM_SINGLE("RINPUT3 Switch", LE89156_ROUTMIX, 7, 1, 0),
++SOC_DAPM_SINGLE("Boost Bypass Switch", LE89156_BYPASS2, 7, 1, 0),
++};
++
++static const struct snd_kcontrol_new le89156_mono_out[] = {
++SOC_DAPM_SINGLE("Left Switch", LE89156_MONOMIX1, 7, 1, 0),
++SOC_DAPM_SINGLE("Right Switch", LE89156_MONOMIX2, 7, 1, 0),
++};
++
++static const struct snd_soc_dapm_widget le89156_dapm_widgets[] = {
++SND_SOC_DAPM_INPUT("LINPUT1"),
++SND_SOC_DAPM_INPUT("RINPUT1"),
++SND_SOC_DAPM_INPUT("LINPUT2"),
++SND_SOC_DAPM_INPUT("RINPUT2"),
++SND_SOC_DAPM_INPUT("LINPUT3"),
++SND_SOC_DAPM_INPUT("RINPUT3"),
++
++SND_SOC_DAPM_SUPPLY("MICB", LE89156_POWER1, 1, 0, NULL, 0),
++
++SND_SOC_DAPM_MIXER("Left Boost Mixer", LE89156_POWER1, 5, 0,
++		   le89156_lin_boost, ARRAY_SIZE(le89156_lin_boost)),
++SND_SOC_DAPM_MIXER("Right Boost Mixer", LE89156_POWER1, 4, 0,
++		   le89156_rin_boost, ARRAY_SIZE(le89156_rin_boost)),
++
++SND_SOC_DAPM_MIXER("Left Input Mixer", LE89156_POWER3, 5, 0,
++		   le89156_lin, ARRAY_SIZE(le89156_lin)),
++SND_SOC_DAPM_MIXER("Right Input Mixer", LE89156_POWER3, 4, 0,
++		   le89156_rin, ARRAY_SIZE(le89156_rin)),
++
++SND_SOC_DAPM_ADC("Left ADC", "Capture", LE89156_POWER1, 3, 0),
++SND_SOC_DAPM_ADC("Right ADC", "Capture", LE89156_POWER1, 2, 0),
++
++SND_SOC_DAPM_DAC("Left DAC", "Playback", LE89156_POWER2, 8, 0),
++SND_SOC_DAPM_DAC("Right DAC", "Playback", LE89156_POWER2, 7, 0),
++
++SND_SOC_DAPM_MIXER("Left Output Mixer", LE89156_POWER3, 3, 0,
++	&le89156_loutput_mixer[0],
++	ARRAY_SIZE(le89156_loutput_mixer)),
++SND_SOC_DAPM_MIXER("Right Output Mixer", LE89156_POWER3, 2, 0,
++	&le89156_routput_mixer[0],
++	ARRAY_SIZE(le89156_routput_mixer)),
++
++SND_SOC_DAPM_PGA("LOUT1 PGA", LE89156_POWER2, 6, 0, NULL, 0),
++SND_SOC_DAPM_PGA("ROUT1 PGA", LE89156_POWER2, 5, 0, NULL, 0),
++
++SND_SOC_DAPM_PGA("Left Speaker PGA", LE89156_POWER2, 4, 0, NULL, 0),
++SND_SOC_DAPM_PGA("Right Speaker PGA", LE89156_POWER2, 3, 0, NULL, 0),
++
++SND_SOC_DAPM_PGA("Right Speaker Output", LE89156_CLASSD1, 7, 0, NULL, 0),
++SND_SOC_DAPM_PGA("Left Speaker Output", LE89156_CLASSD1, 6, 0, NULL, 0),
++
++SND_SOC_DAPM_OUTPUT("SPK_LP"),
++SND_SOC_DAPM_OUTPUT("SPK_LN"),
++SND_SOC_DAPM_OUTPUT("HP_L"),
++SND_SOC_DAPM_OUTPUT("HP_R"),
++SND_SOC_DAPM_OUTPUT("SPK_RP"),
++SND_SOC_DAPM_OUTPUT("SPK_RN"),
++SND_SOC_DAPM_OUTPUT("OUT3"),
++};
++
++static const struct snd_soc_dapm_widget le89156_dapm_widgets_out3[] = {
++SND_SOC_DAPM_MIXER("Mono Output Mixer", LE89156_POWER2, 1, 0,
++	&le89156_mono_out[0],
++	ARRAY_SIZE(le89156_mono_out)),
++};
++
++/* Represent OUT3 as a PGA so that it gets turned on with LOUT1/ROUT1 */
++static const struct snd_soc_dapm_widget le89156_dapm_widgets_capless[] = {
++SND_SOC_DAPM_PGA("OUT3 VMID", LE89156_POWER2, 1, 0, NULL, 0),
++};
++
++static const struct snd_soc_dapm_route audio_paths[] = {
++	{ "Left Boost Mixer", "LINPUT1 Switch", "LINPUT1" },
++	{ "Left Boost Mixer", "LINPUT2 Switch", "LINPUT2" },
++	{ "Left Boost Mixer", "LINPUT3 Switch", "LINPUT3" },
++
++	{ "Left Input Mixer", "Boost Switch", "Left Boost Mixer", },
++	{ "Left Input Mixer", NULL, "LINPUT1", },  /* Really Boost Switch */
++	{ "Left Input Mixer", NULL, "LINPUT2" },
++	{ "Left Input Mixer", NULL, "LINPUT3" },
++
++	{ "Right Boost Mixer", "RINPUT1 Switch", "RINPUT1" },
++	{ "Right Boost Mixer", "RINPUT2 Switch", "RINPUT2" },
++	{ "Right Boost Mixer", "RINPUT3 Switch", "RINPUT3" },
++
++	{ "Right Input Mixer", "Boost Switch", "Right Boost Mixer", },
++	{ "Right Input Mixer", NULL, "RINPUT1", },  /* Really Boost Switch */
++	{ "Right Input Mixer", NULL, "RINPUT2" },
++	{ "Right Input Mixer", NULL, "LINPUT3" },
++
++	{ "Left ADC", NULL, "Left Input Mixer" },
++	{ "Right ADC", NULL, "Right Input Mixer" },
++
++	{ "Left Output Mixer", "LINPUT3 Switch", "LINPUT3" },
++	{ "Left Output Mixer", "Boost Bypass Switch", "Left Boost Mixer"} ,
++	{ "Left Output Mixer", "PCM Playback Switch", "Left DAC" },
++
++	{ "Right Output Mixer", "RINPUT3 Switch", "RINPUT3" },
++	{ "Right Output Mixer", "Boost Bypass Switch", "Right Boost Mixer" } ,
++	{ "Right Output Mixer", "PCM Playback Switch", "Right DAC" },
++
++	{ "LOUT1 PGA", NULL, "Left Output Mixer" },
++	{ "ROUT1 PGA", NULL, "Right Output Mixer" },
++
++	{ "HP_L", NULL, "LOUT1 PGA" },
++	{ "HP_R", NULL, "ROUT1 PGA" },
++
++	{ "Left Speaker PGA", NULL, "Left Output Mixer" },
++	{ "Right Speaker PGA", NULL, "Right Output Mixer" },
++
++	{ "Left Speaker Output", NULL, "Left Speaker PGA" },
++	{ "Right Speaker Output", NULL, "Right Speaker PGA" },
++
++	{ "SPK_LN", NULL, "Left Speaker Output" },
++	{ "SPK_LP", NULL, "Left Speaker Output" },
++	{ "SPK_RN", NULL, "Right Speaker Output" },
++	{ "SPK_RP", NULL, "Right Speaker Output" },
++};
++
++static const struct snd_soc_dapm_route audio_paths_out3[] = {
++	{ "Mono Output Mixer", "Left Switch", "Left Output Mixer" },
++	{ "Mono Output Mixer", "Right Switch", "Right Output Mixer" },
++
++	{ "OUT3", NULL, "Mono Output Mixer", }
++};
++
++static const struct snd_soc_dapm_route audio_paths_capless[] = {
++	{ "HP_L", NULL, "OUT3 VMID" },
++	{ "HP_R", NULL, "OUT3 VMID" },
++
++	{ "OUT3 VMID", NULL, "Left Output Mixer" },
++	{ "OUT3 VMID", NULL, "Right Output Mixer" },
++};
++
++static int le89156_add_widgets(struct snd_soc_codec *codec)
++{
++	struct le89156_data *pdata = codec->dev->platform_data;
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	struct snd_soc_dapm_context *dapm = &codec->dapm;
++	struct snd_soc_dapm_widget *w;
++
++	snd_soc_dapm_new_controls(dapm, le89156_dapm_widgets,
++				  ARRAY_SIZE(le89156_dapm_widgets));
++
++	snd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));
++
++	/* In capless mode OUT3 is used to provide VMID for the
++	 * headphone outputs, otherwise it is used as a mono mixer.
++	 */
++	if (pdata && pdata->capless) {
++		snd_soc_dapm_new_controls(dapm, le89156_dapm_widgets_capless,
++					  ARRAY_SIZE(le89156_dapm_widgets_capless));
++
++		snd_soc_dapm_add_routes(dapm, audio_paths_capless,
++					ARRAY_SIZE(audio_paths_capless));
++	} else {
++		snd_soc_dapm_new_controls(dapm, le89156_dapm_widgets_out3,
++					  ARRAY_SIZE(le89156_dapm_widgets_out3));
++
++		snd_soc_dapm_add_routes(dapm, audio_paths_out3,
++					ARRAY_SIZE(audio_paths_out3));
++	}
++
++	/* We need to power up the headphone output stage out of
++	 * sequence for capless mode.  To save scanning the widget
++	 * list each time to find the desired power state do so now
++	 * and save the result.
++	 */
++	list_for_each_entry(w, &codec->card->widgets, list) {
++		if (w->dapm != &codec->dapm)
++			continue;
++		if (strcmp(w->name, "LOUT1 PGA") == 0)
++			le89156->lout1 = w;
++		if (strcmp(w->name, "ROUT1 PGA") == 0)
++			le89156->rout1 = w;
++		if (strcmp(w->name, "OUT3 VMID") == 0)
++			le89156->out3 = w;
++	}
++
++	return 0;
++}
++
++static int le89156_set_dai_fmt(struct snd_soc_dai *codec_dai,
++		unsigned int fmt)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u16 iface = 0;
++
++	/* set master/slave audio interface */
++	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
++	case SND_SOC_DAIFMT_CBM_CFM:
++		iface |= 0x0040;
++		break;
++	case SND_SOC_DAIFMT_CBS_CFS:
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	/* interface format */
++	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
++	case SND_SOC_DAIFMT_I2S:
++		iface |= 0x0002;
++		break;
++	case SND_SOC_DAIFMT_RIGHT_J:
++		break;
++	case SND_SOC_DAIFMT_LEFT_J:
++		iface |= 0x0001;
++		break;
++	case SND_SOC_DAIFMT_DSP_A:
++		iface |= 0x0003;
++		break;
++	case SND_SOC_DAIFMT_DSP_B:
++		iface |= 0x0013;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	/* clock inversion */
++	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
++	case SND_SOC_DAIFMT_NB_NF:
++		break;
++	case SND_SOC_DAIFMT_IB_IF:
++		iface |= 0x0090;
++		break;
++	case SND_SOC_DAIFMT_IB_NF:
++		iface |= 0x0080;
++		break;
++	case SND_SOC_DAIFMT_NB_IF:
++		iface |= 0x0010;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	/* set iface */
++	snd_soc_write(codec, LE89156_IFACE1, iface);
++	return 0;
++}
++
++static struct {
++	int rate;
++	unsigned int val;
++} alc_rates[] = {
++	{ 48000, 0 },
++	{ 44100, 0 },
++	{ 32000, 1 },
++	{ 22050, 2 },
++	{ 24000, 2 },
++	{ 16000, 3 },
++	{ 11250, 4 },
++	{ 12000, 4 },
++	{  8000, 5 },
++};
++
++static int le89156_hw_params(struct snd_pcm_substream *substream,
++			    struct snd_pcm_hw_params *params,
++			    struct snd_soc_dai *dai)
++{
++	struct snd_soc_codec *codec = dai->codec;
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	u16 iface = snd_soc_read(codec, LE89156_IFACE1) & 0xfff3;
++	snd_pcm_format_t format = params_format(params);
++	int i;
++
++	/* bit size */
++	switch (format) {
++	case SNDRV_PCM_FORMAT_S16_LE:
++	case SNDRV_PCM_FORMAT_S16_BE:
++		break;
++	case SNDRV_PCM_FORMAT_S20_3LE:
++	case SNDRV_PCM_FORMAT_S20_3BE:
++		iface |= 0x0004;
++		break;
++	case SNDRV_PCM_FORMAT_S24_LE:
++	case SNDRV_PCM_FORMAT_S24_BE:
++		iface |= 0x0008;
++		break;
++	default:
++		dev_err(codec->dev, "unsupported format %i\n", format);
++		return -EINVAL;
++	}
++
++	/* Update filters for the new rate */
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++		le89156->playback_fs = params_rate(params);
++		le89156_set_deemph(codec);
++	} else {
++		for (i = 0; i < ARRAY_SIZE(alc_rates); i++)
++			if (alc_rates[i].rate == params_rate(params))
++				snd_soc_update_bits(codec,
++						    LE89156_ADDCTL3, 0x7,
++						    alc_rates[i].val);
++	}
++
++	/* set iface */
++	snd_soc_write(codec, LE89156_IFACE1, iface);
++	return 0;
++}
++
++static int le89156_mute(struct snd_soc_dai *dai, int mute)
++{
++	struct snd_soc_codec *codec = dai->codec;
++
++	if (mute)
++		snd_soc_update_bits(codec, LE89156_DACCTL1, 0x8, 0x8);
++	else
++		snd_soc_update_bits(codec, LE89156_DACCTL1, 0x8, 0);
++	return 0;
++}
++
++static int le89156_set_bias_level_out3(struct snd_soc_codec *codec,
++				      enum snd_soc_bias_level level)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++
++	switch (level) {
++	case SND_SOC_BIAS_ON:
++		break;
++
++	case SND_SOC_BIAS_PREPARE:
++		/* Set VMID to 2x50k */
++		snd_soc_update_bits(codec, LE89156_POWER1, 0x180, 0x80);
++		break;
++
++	case SND_SOC_BIAS_STANDBY:
++		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
++			regcache_sync(le89156->regmap);
++
++			/* Enable anti-pop features */
++			snd_soc_write(codec, LE89156_APOP1,
++				      LE89156_POBCTRL | LE89156_SOFT_ST |
++				      LE89156_BUFDCOPEN | LE89156_BUFIOEN);
++
++			/* Enable & ramp VMID at 2x50k */
++			snd_soc_update_bits(codec, LE89156_POWER1, 0x80, 0x80);
++			msleep(100);
++
++			/* Enable VREF */
++			snd_soc_update_bits(codec, LE89156_POWER1, LE89156_VREF,
++					    LE89156_VREF);
++
++			/* Disable anti-pop features */
++			snd_soc_write(codec, LE89156_APOP1, LE89156_BUFIOEN);
++		}
++
++		/* Set VMID to 2x250k */
++		snd_soc_update_bits(codec, LE89156_POWER1, 0x180, 0x100);
++		break;
++
++	case SND_SOC_BIAS_OFF:
++		/* Enable anti-pop features */
++		snd_soc_write(codec, LE89156_APOP1,
++			     LE89156_POBCTRL | LE89156_SOFT_ST |
++			     LE89156_BUFDCOPEN | LE89156_BUFIOEN);
++
++		/* Disable VMID and VREF, let them discharge */
++		snd_soc_write(codec, LE89156_POWER1, 0);
++		msleep(600);
++		break;
++	}
++
++	codec->dapm.bias_level = level;
++
++	return 0;
++}
++
++static int le89156_set_bias_level_capless(struct snd_soc_codec *codec,
++					 enum snd_soc_bias_level level)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	int reg;
++
++	switch (level) {
++	case SND_SOC_BIAS_ON:
++		break;
++
++	case SND_SOC_BIAS_PREPARE:
++		switch (codec->dapm.bias_level) {
++		case SND_SOC_BIAS_STANDBY:
++			/* Enable anti pop mode */
++			snd_soc_update_bits(codec, LE89156_APOP1,
++					    LE89156_POBCTRL | LE89156_SOFT_ST |
++					    LE89156_BUFDCOPEN,
++					    LE89156_POBCTRL | LE89156_SOFT_ST |
++					    LE89156_BUFDCOPEN);
++
++			/* Enable LOUT1, ROUT1 and OUT3 if they're enabled */
++			reg = 0;
++			if (le89156->lout1 && le89156->lout1->power)
++				reg |= LE89156_PWR2_LOUT1;
++			if (le89156->rout1 && le89156->rout1->power)
++				reg |= LE89156_PWR2_ROUT1;
++			if (le89156->out3 && le89156->out3->power)
++				reg |= LE89156_PWR2_OUT3;
++			snd_soc_update_bits(codec, LE89156_POWER2,
++					    LE89156_PWR2_LOUT1 |
++					    LE89156_PWR2_ROUT1 |
++					    LE89156_PWR2_OUT3, reg);
++
++			/* Enable VMID at 2*50k */
++			snd_soc_update_bits(codec, LE89156_POWER1,
++					    LE89156_VMID_MASK, 0x80);
++
++			/* Ramp */
++			msleep(100);
++
++			/* Enable VREF */
++			snd_soc_update_bits(codec, LE89156_POWER1,
++					    LE89156_VREF, LE89156_VREF);
++
++			msleep(100);
++			break;
++
++		case SND_SOC_BIAS_ON:
++			/* Enable anti-pop mode */
++			snd_soc_update_bits(codec, LE89156_APOP1,
++					    LE89156_POBCTRL | LE89156_SOFT_ST |
++					    LE89156_BUFDCOPEN,
++					    LE89156_POBCTRL | LE89156_SOFT_ST |
++					    LE89156_BUFDCOPEN);
++
++			/* Disable VMID and VREF */
++			snd_soc_update_bits(codec, LE89156_POWER1,
++					    LE89156_VREF | LE89156_VMID_MASK, 0);
++			break;
++
++		case SND_SOC_BIAS_OFF:
++			regcache_sync(le89156->regmap);
++			break;
++		default:
++			break;
++		}
++		break;
++
++	case SND_SOC_BIAS_STANDBY:
++		switch (codec->dapm.bias_level) {
++		case SND_SOC_BIAS_PREPARE:
++			/* Disable HP discharge */
++			snd_soc_update_bits(codec, LE89156_APOP2,
++					    LE89156_DISOP | LE89156_DRES_MASK,
++					    0);
++
++			/* Disable anti-pop features */
++			snd_soc_update_bits(codec, LE89156_APOP1,
++					    LE89156_POBCTRL | LE89156_SOFT_ST |
++					    LE89156_BUFDCOPEN,
++					    LE89156_POBCTRL | LE89156_SOFT_ST |
++					    LE89156_BUFDCOPEN);
++			break;
++
++		default:
++			break;
++		}
++		break;
++
++	case SND_SOC_BIAS_OFF:
++		break;
++	}
++
++	codec->dapm.bias_level = level;
++
++	return 0;
++}
++
++/* PLL divisors */
++struct _pll_div {
++	u32 pre_div:1;
++	u32 n:4;
++	u32 k:24;
++};
++
++/* The size in bits of the pll divide multiplied by 10
++ * to allow rounding later */
++#define FIXED_PLL_SIZE ((1 << 24) * 10)
++
++static int pll_factors(unsigned int source, unsigned int target,
++		       struct _pll_div *pll_div)
++{
++	unsigned long long Kpart;
++	unsigned int K, Ndiv, Nmod;
++
++	pr_debug("LE89156 PLL: setting %dHz->%dHz\n", source, target);
++
++	/* Scale up target to PLL operating frequency */
++	target *= 4;
++
++	Ndiv = target / source;
++	if (Ndiv < 6) {
++		source >>= 1;
++		pll_div->pre_div = 1;
++		Ndiv = target / source;
++	} else
++		pll_div->pre_div = 0;
++
++	if ((Ndiv < 6) || (Ndiv > 12)) {
++		pr_err("LE89156 PLL: Unsupported N=%d\n", Ndiv);
++		return -EINVAL;
++	}
++
++	pll_div->n = Ndiv;
++	Nmod = target % source;
++	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
++
++	do_div(Kpart, source);
++
++	K = Kpart & 0xFFFFFFFF;
++
++	/* Check if we need to round */
++	if ((K % 10) >= 5)
++		K += 5;
++
++	/* Move down to proper range now rounding is done */
++	K /= 10;
++
++	pll_div->k = K;
++
++	pr_debug("LE89156 PLL: N=%x K=%x pre_div=%d\n",
++		 pll_div->n, pll_div->k, pll_div->pre_div);
++
++	return 0;
++}
++
++static int le89156_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
++		int source, unsigned int freq_in, unsigned int freq_out)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u16 reg;
++	static struct _pll_div pll_div;
++	int ret;
++
++	if (freq_in && freq_out) {
++		ret = pll_factors(freq_in, freq_out, &pll_div);
++		if (ret != 0)
++			return ret;
++	}
++
++	/* Disable the PLL: even if we are changing the frequency the
++	 * PLL needs to be disabled while we do so. */
++	snd_soc_update_bits(codec, LE89156_CLOCK1, 0x1, 0);
++	snd_soc_update_bits(codec, LE89156_POWER2, 0x1, 0);
++
++	if (!freq_in || !freq_out)
++		return 0;
++
++	reg = snd_soc_read(codec, LE89156_PLL1) & ~0x3f;
++	reg |= pll_div.pre_div << 4;
++	reg |= pll_div.n;
++
++	if (pll_div.k) {
++		reg |= 0x20;
++
++		snd_soc_write(codec, LE89156_PLL2, (pll_div.k >> 16) & 0xff);
++		snd_soc_write(codec, LE89156_PLL3, (pll_div.k >> 8) & 0xff);
++		snd_soc_write(codec, LE89156_PLL4, pll_div.k & 0xff);
++	}
++	snd_soc_write(codec, LE89156_PLL1, reg);
++
++	/* Turn it on */
++	snd_soc_update_bits(codec, LE89156_POWER2, 0x1, 0x1);
++	msleep(250);
++	snd_soc_update_bits(codec, LE89156_CLOCK1, 0x1, 0x1);
++
++	return 0;
++}
++
++static int le89156_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
++		int div_id, int div)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u16 reg;
++
++	switch (div_id) {
++	case LE89156_SYSCLKDIV:
++		reg = snd_soc_read(codec, LE89156_CLOCK1) & 0x1f9;
++		snd_soc_write(codec, LE89156_CLOCK1, reg | div);
++		break;
++	case LE89156_DACDIV:
++		reg = snd_soc_read(codec, LE89156_CLOCK1) & 0x1c7;
++		snd_soc_write(codec, LE89156_CLOCK1, reg | div);
++		break;
++	case LE89156_OPCLKDIV:
++		reg = snd_soc_read(codec, LE89156_PLL1) & 0x03f;
++		snd_soc_write(codec, LE89156_PLL1, reg | div);
++		break;
++	case LE89156_DCLKDIV:
++		reg = snd_soc_read(codec, LE89156_CLOCK2) & 0x03f;
++		snd_soc_write(codec, LE89156_CLOCK2, reg | div);
++		break;
++	case LE89156_TOCLKSEL:
++		reg = snd_soc_read(codec, LE89156_ADDCTL1) & 0x1fd;
++		snd_soc_write(codec, LE89156_ADDCTL1, reg | div);
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static int le89156_set_bias_level(struct snd_soc_codec *codec,
++				 enum snd_soc_bias_level level)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++
++	return le89156->set_bias_level(codec, level);
++}
++
++#define LE89156_RATES SNDRV_PCM_RATE_8000_48000
++
++#define LE89156_FORMATS \
++	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
++	SNDRV_PCM_FMTBIT_S24_LE)
++
++static const struct snd_soc_dai_ops le89156_dai_ops = {
++	.hw_params = le89156_hw_params,
++	.digital_mute = le89156_mute,
++	.set_fmt = le89156_set_dai_fmt,
++	.set_clkdiv = le89156_set_dai_clkdiv,
++	.set_pll = le89156_set_dai_pll,
++};
++
++static struct snd_soc_dai_driver le89156_dai = {
++	.name = "le89156-hifi",
++	.playback = {
++		.stream_name = "Playback",
++		.channels_min = 1,
++		.channels_max = 2,
++		.rates = LE89156_RATES,
++		.formats = LE89156_FORMATS,},
++	.capture = {
++		.stream_name = "Capture",
++		.channels_min = 1,
++		.channels_max = 2,
++		.rates = LE89156_RATES,
++		.formats = LE89156_FORMATS,},
++	.ops = &le89156_dai_ops,
++	.symmetric_rates = 1,
++};
++
++static int le89156_suspend(struct snd_soc_codec *codec)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++
++	le89156->set_bias_level(codec, SND_SOC_BIAS_OFF);
++	return 0;
++}
++
++static int le89156_resume(struct snd_soc_codec *codec)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++
++	le89156->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
++	return 0;
++}
++
++static int le89156_probe(struct snd_soc_codec *codec)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	struct le89156_data *pdata = dev_get_platdata(codec->dev);
++	int ret;
++
++	le89156->set_bias_level = le89156_set_bias_level_out3;
++
++	if (!pdata) {
++		dev_warn(codec->dev, "No platform data supplied\n");
++	} else {
++		if (pdata->capless)
++			le89156->set_bias_level = le89156_set_bias_level_capless;
++	}
++
++	ret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);
++	if (ret < 0) {
++		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
++		return ret;
++	}
++
++	ret = le89156_reset(codec);
++	if (ret < 0) {
++		dev_err(codec->dev, "Failed to issue reset\n");
++		return ret;
++	}
++
++	le89156->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
++
++	/* Latch the update bits */
++	snd_soc_update_bits(codec, LE89156_LINVOL, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_RINVOL, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_LADC, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_RADC, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_LDAC, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_RDAC, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_LOUT1, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_ROUT1, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_LOUT2, 0x100, 0x100);
++	snd_soc_update_bits(codec, LE89156_ROUT2, 0x100, 0x100);
++
++	snd_soc_add_codec_controls(codec, le89156_snd_controls,
++				     ARRAY_SIZE(le89156_snd_controls));
++	le89156_add_widgets(codec);
++
++	return 0;
++}
++
++/* power down chip */
++static int le89156_remove(struct snd_soc_codec *codec)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++
++	le89156->set_bias_level(codec, SND_SOC_BIAS_OFF);
++	return 0;
++}
++
++static struct snd_soc_codec_driver soc_codec_dev_le89156 = {
++	.probe =	le89156_probe,
++	.remove =	le89156_remove,
++	.suspend =	le89156_suspend,
++	.resume =	le89156_resume,
++	.set_bias_level = le89156_set_bias_level,
++};
++
++static const struct regmap_config le89156_regmap = {
++	.reg_bits = 7,
++	.val_bits = 9,
++	.max_register = LE89156_PLL4,
++
++	.reg_defaults = le89156_reg_defaults,
++	.num_reg_defaults = ARRAY_SIZE(le89156_reg_defaults),
++	.cache_type = REGCACHE_RBTREE,
++
++	.volatile_reg = le89156_volatile,
++};
++
++static int le89156_i2c_probe(struct i2c_client *i2c,
++			    const struct i2c_device_id *id)
++{
++	struct le89156_data *pdata = dev_get_platdata(&i2c->dev);
++	struct le89156_priv *le89156;
++	int ret;
++
++	le89156 = devm_kzalloc(&i2c->dev, sizeof(struct le89156_priv),
++			      GFP_KERNEL);
++	if (le89156 == NULL)
++		return -ENOMEM;
++
++	le89156->regmap = devm_regmap_init_i2c(i2c, &le89156_regmap);
++	if (IS_ERR(le89156->regmap))
++		return PTR_ERR(le89156->regmap);
++
++	if (pdata && pdata->shared_lrclk) {
++		ret = regmap_update_bits(le89156->regmap, LE89156_ADDCTL2,
++					 0x4, 0x4);
++		if (ret != 0) {
++			dev_err(&i2c->dev, "Failed to enable LRCM: %d\n",
++				ret);
++			return ret;
++		}
++	}
++
++	i2c_set_clientdata(i2c, le89156);
++
++	ret = snd_soc_register_codec(&i2c->dev,
++			&soc_codec_dev_le89156, &le89156_dai, 1);
++
++	return ret;
++}
++
++static int le89156_i2c_remove(struct i2c_client *client)
++{
++	snd_soc_unregister_codec(&client->dev);
++	return 0;
++}
++
++static const struct i2c_device_id le89156_i2c_id[] = {
++	{ "le89156", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, le89156_i2c_id);
++
++static struct i2c_driver le89156_i2c_driver = {
++	.driver = {
++		.name = "le89156",
++		.owner = THIS_MODULE,
++	},
++	.probe =    le89156_i2c_probe,
++	.remove =   le89156_i2c_remove,
++	.id_table = le89156_i2c_id,
++};
++
++module_i2c_driver(le89156_i2c_driver);
++
++MODULE_DESCRIPTION("ASoC LE89156 driver");
++MODULE_AUTHOR("Liam Girdwood");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/sound/soc/codecs/le89156.h
+@@ -0,0 +1,113 @@
++/*
++ * le89156.h  --  LE89156 Soc Audio driver
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#ifndef _LE89156_H
++#define _LE89156_H
++
++/* LE89156 register space */
++
++
++#define LE89156_CACHEREGNUM 	56
++
++#define LE89156_LINVOL		0x0
++#define LE89156_RINVOL		0x1
++#define LE89156_LOUT1		0x2
++#define LE89156_ROUT1		0x3
++#define LE89156_CLOCK1		0x4
++#define LE89156_DACCTL1		0x5
++#define LE89156_DACCTL2		0x6
++#define LE89156_IFACE1		0x7
++#define LE89156_CLOCK2		0x8
++#define LE89156_IFACE2		0x9
++#define LE89156_LDAC		0xa
++#define LE89156_RDAC		0xb
++
++#define LE89156_RESET		0xf
++#define LE89156_3D		0x10
++#define LE89156_ALC1		0x11
++#define LE89156_ALC2		0x12
++#define LE89156_ALC3		0x13
++#define LE89156_NOISEG		0x14
++#define LE89156_LADC		0x15
++#define LE89156_RADC		0x16
++#define LE89156_ADDCTL1		0x17
++#define LE89156_ADDCTL2		0x18
++#define LE89156_POWER1		0x19
++#define LE89156_POWER2		0x1a
++#define LE89156_ADDCTL3		0x1b
++#define LE89156_APOP1		0x1c
++#define LE89156_APOP2		0x1d
++
++#define LE89156_LINPATH		0x20
++#define LE89156_RINPATH		0x21
++#define LE89156_LOUTMIX		0x22
++
++#define LE89156_ROUTMIX		0x25
++#define LE89156_MONOMIX1		0x26
++#define LE89156_MONOMIX2		0x27
++#define LE89156_LOUT2		0x28
++#define LE89156_ROUT2		0x29
++#define LE89156_MONO		0x2a
++#define LE89156_INBMIX1		0x2b
++#define LE89156_INBMIX2		0x2c
++#define LE89156_BYPASS1		0x2d
++#define LE89156_BYPASS2		0x2e
++#define LE89156_POWER3		0x2f
++#define LE89156_ADDCTL4		0x30
++#define LE89156_CLASSD1		0x31
++
++#define LE89156_CLASSD3		0x33
++#define LE89156_PLL1		0x34
++#define LE89156_PLL2		0x35
++#define LE89156_PLL3		0x36
++#define LE89156_PLL4		0x37
++
++
++/*
++ * LE89156 Clock dividers
++ */
++#define LE89156_SYSCLKDIV 		0
++#define LE89156_DACDIV			1
++#define LE89156_OPCLKDIV			2
++#define LE89156_DCLKDIV			3
++#define LE89156_TOCLKSEL			4
++
++#define LE89156_SYSCLK_DIV_1		(0 << 1)
++#define LE89156_SYSCLK_DIV_2		(2 << 1)
++
++#define LE89156_SYSCLK_MCLK		(0 << 0)
++#define LE89156_SYSCLK_PLL		(1 << 0)
++
++#define LE89156_DAC_DIV_1		(0 << 3)
++#define LE89156_DAC_DIV_1_5		(1 << 3)
++#define LE89156_DAC_DIV_2		(2 << 3)
++#define LE89156_DAC_DIV_3		(3 << 3)
++#define LE89156_DAC_DIV_4		(4 << 3)
++#define LE89156_DAC_DIV_5_5		(5 << 3)
++#define LE89156_DAC_DIV_6		(6 << 3)
++
++#define LE89156_DCLK_DIV_1_5		(0 << 6)
++#define LE89156_DCLK_DIV_2		(1 << 6)
++#define LE89156_DCLK_DIV_3		(2 << 6)
++#define LE89156_DCLK_DIV_4		(3 << 6)
++#define LE89156_DCLK_DIV_6		(4 << 6)
++#define LE89156_DCLK_DIV_8		(5 << 6)
++#define LE89156_DCLK_DIV_12		(6 << 6)
++#define LE89156_DCLK_DIV_16		(7 << 6)
++
++#define LE89156_TOCLK_F19		(0 << 1)
++#define LE89156_TOCLK_F21		(1 << 1)
++
++#define LE89156_OPCLK_DIV_1		(0 << 0)
++#define LE89156_OPCLK_DIV_2		(1 << 0)
++#define LE89156_OPCLK_DIV_3		(2 << 0)
++#define LE89156_OPCLK_DIV_4		(3 << 0)
++#define LE89156_OPCLK_DIV_5_5		(4 << 0)
++#define LE89156_OPCLK_DIV_6		(5 << 0)
++
++#endif
+--- a/sound/soc/ralink/Kconfig
++++ b/sound/soc/ralink/Kconfig
+@@ -13,3 +13,19 @@ config SND_MT7620_SOC_WM8960
+ 	help
+ 	  Say Y if you want to add support for ASoC audio on the Qi LB60 board
+ 	  a.k.a Qi Ben NanoNote.
++
++config SND_RT5350_SOC_PCM
++	depends on SOC_RT5350 && SND_SOC
++	select SND_SOC_GENERIC_DMAENGINE_PCM
++	tristate "SoC Audio (PCM protocol) for Ralink RT5350 SoC"
++	help
++	  Say Y if you want to use I2S protocol and PCM codec on Ralink RT5350
++	  based boards.
++
++config SND_RT5350_SOC_LE89156
++	tristate "SoC Audio support for Ralink with Zarlink SLIC"
++	select SND_RT5350_SOC_PCM
++	select SND_SOC_LE89156
++	help
++	  Say Y if you want to add support for ASoC audio on the Ralink with PCM
++	  based Zarlink LE89156 SLIC.
+--- a/sound/soc/ralink/Makefile
++++ b/sound/soc/ralink/Makefile
+@@ -9,3 +9,16 @@ obj-$(CONFIG_SND_MT7620_SOC_I2S) += snd-
+ snd-soc-mt7620-wm8960-objs := mt7620-wm8960.o
+ 
+ obj-$(CONFIG_SND_MT7620_SOC_WM8960) += snd-soc-mt7620-wm8960.o
++
++#
++# RT5350 Platform Support
++#
++snd-soc-rt5350-pcm-objs := rt5350-pcm.o
++
++obj-$(CONFIG_SND_RT5350_SOC_PCM) += snd-soc-rt5350-pcm.o
++
++# RT5350 Machine Support
++snd-soc-rt5350-le89156-objs := rt5350-le89156.o
++
++obj-$(CONFIG_SND_RT5350_SOC_LE89156) += snd-soc-rt5350-le89156.o
++
+--- /dev/null
++++ b/sound/soc/ralink/rt5350-le89156.c
+@@ -0,0 +1,125 @@
++/*
++ * Copyright (C) 2009, Lars-Peter Clausen <lars@metafoo.de>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ *  You should have received a copy of the  GNU General Public License along
++ *  with this program; if not, write  to the Free Software Foundation, Inc.,
++ *  675 Mass Ave, Cambridge, MA 02139, USA.
++ *
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/of.h>
++#include <linux/timer.h>
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/soc.h>
++
++
++static const struct snd_soc_dapm_widget rt5350_le89156_widgets[] = {
++	SND_SOC_DAPM_SPK("Speaker", NULL),
++};
++
++static const struct snd_soc_dapm_route rt5350_le89156_routes[] = {
++	{"Speaker", NULL, "HP_L"},
++	{"Speaker", NULL, "HP_R"},
++};
++
++#define RT5350_DAIFMT (SND_SOC_DAIFMT_I2S | \
++			SND_SOC_DAIFMT_NB_NF | \
++			SND_SOC_DAIFMT_CBM_CFM)
++
++static int rt5350_le89156_codec_init(struct snd_soc_pcm_runtime *rtd)
++{
++	struct snd_soc_codec *codec = rtd->codec;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++	struct snd_soc_dapm_context *dapm = &codec->dapm;
++	int ret;
++
++	snd_soc_dapm_enable_pin(dapm, "HP_L");
++	snd_soc_dapm_enable_pin(dapm, "HP_R");
++
++	ret = snd_soc_dai_set_fmt(cpu_dai, RT5350_DAIFMT);
++	if (ret < 0) {
++		dev_err(codec->dev, "Failed to set cpu dai format: %d\n", ret);
++		return ret;
++	}
++
++	return 0;
++}
++
++static struct snd_soc_dai_link rt5350_le89156_dai = {
++	.name = "rt5350",
++	.stream_name = "rt5350",
++	.init = rt5350_le89156_codec_init,
++	.codec_dai_name = "le89156-hifi",
++};
++
++static struct snd_soc_card rt5350_le89156 = {
++	.name = "rt5350-le89156",
++	.owner = THIS_MODULE,
++	.dai_link = &rt5350_le89156_dai,
++	.num_links = 1,
++
++	.dapm_widgets = rt5350_le89156_widgets,
++	.num_dapm_widgets = ARRAY_SIZE(rt5350_le89156_widgets),
++	.dapm_routes = rt5350_le89156_routes,
++	.num_dapm_routes = ARRAY_SIZE(rt5350_le89156_routes),
++};
++
++static int rt5350_le89156_probe(struct platform_device *pdev)
++{
++	struct device_node *np = pdev->dev.of_node;
++	struct snd_soc_card *card = &rt5350_le89156;
++	int ret;
++
++	card->dev = &pdev->dev;
++
++	rt5350_le89156_dai.cpu_of_node = of_parse_phandle(np, "controller", 0);
++	rt5350_le89156_dai.codec_of_node = of_parse_phandle(np, "codec", 0);
++	rt5350_le89156_dai.platform_of_node = rt5350_le89156_dai.cpu_of_node;
++
++	ret = snd_soc_register_card(card);
++	if (ret) {
++		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
++			ret);
++	}
++	return ret;
++}
++
++static int rt5350_le89156_remove(struct platform_device *pdev)
++{
++	struct snd_soc_card *card = platform_get_drvdata(pdev);
++
++	snd_soc_unregister_card(card);
++	return 0;
++}
++
++static const struct of_device_id rt5350_audio_match[] = {
++	{ .compatible = "ralink,le89156-audio" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, rt5350_audio_match);
++
++static struct platform_driver rt5350_le89156_driver = {
++	.driver		= {
++		.name	= "le89156-audio",
++		.owner	= THIS_MODULE,
++		.of_match_table = rt5350_audio_match,
++	},
++	.probe		= rt5350_le89156_probe,
++	.remove		= rt5350_le89156_remove,
++};
++
++module_platform_driver(rt5350_le89156_driver);
++
++MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
++MODULE_DESCRIPTION("ALSA SoC RT5350 Zarlink LE89156 support");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:rt5350-le89156-audio");
+--- /dev/null
++++ b/sound/soc/ralink/rt5350-pcm.c
+@@ -0,0 +1,466 @@
++/*
++ *  Copyright (C) 2010, Lars-Peter Clausen <lars@metafoo.de>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under  the terms of the GNU General  Public License as published by the
++ *  Free Software Foundation;  either version 2 of the License, or (at your
++ *  option) any later version.
++ *
++ *  You should have received a copy of the GNU General Public License along
++ *  with this program; if not, write to the Free Software Foundation, Inc.,
++ *  675 Mass Ave, Cambridge, MA 02139, USA.
++ *
++ */
++
++#include <linux/init.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++
++#include <linux/delay.h>
++
++#include <linux/dma-mapping.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++#include <sound/initval.h>
++#include <sound/dmaengine_pcm.h>
++
++#include <ralink_regs.h>
++
++#define PCM_REG_CFG0		0x00
++#define PCM_REG_CFG0_EN		BIT(31)
++#define PCM_REG_CFG0_DMA_EN	BIT(30)
++#define PCM_REG_CFG0_BYTE_SWAP	BIT(28)
++#define PCM_REG_CFG0_TX_EN	BIT(24)
++#define PCM_REG_CFG0_RX_EN	BIT(20)
++#define PCM_REG_CFG0_SLAVE	BIT(16)
++#define PCM_REG_CFG0_RX_THRES	12
++#define PCM_REG_CFG0_TX_THRES	4
++#define PCM_REG_CFG0_DFT_THRES	(4 << PCM_REG_CFG0_RX_THRES) | \
++					(4 << PCM_REG_CFG0_TX_THRES)
++
++#define PCM_REG_INT_STATUS	0x04
++#define PCM_REG_INT_EN		0x08
++#define PCM_REG_FF_STATUS	0x0c
++#define PCM_REG_WREG		0x10
++#define PCM_REG_RREG		0x14
++#define PCM_REG_CFG1		0x18
++
++#define PCM_REG_DIVCMP		0x20
++#define PCM_REG_DIVINT		0x24
++#define PCM_REG_CLK_EN		BIT(31)
++
++struct rt5350_pcm {
++	struct resource *mem;
++	void __iomem *base;
++	dma_addr_t phys_base;
++
++	struct snd_dmaengine_dai_dma_data playback_dma_data;
++	struct snd_dmaengine_dai_dma_data capture_dma_data;
++};
++
++static inline uint32_t rt5350_pcm_read(const struct rt5350_pcm *pcm,
++	unsigned int reg)
++{
++	return readl(pcm->base + reg);
++}
++
++static inline void rt5350_pcm_write(const struct rt5350_pcm *pcm,
++	unsigned int reg, uint32_t value)
++{
++	//printk("pcm --> %p = 0x%08X\n", pcm->base + reg, value);
++	writel(value, pcm->base + reg);
++}
++
++static int rt5350_pcm_startup(struct snd_pcm_substream *substream,
++	struct snd_soc_dai *dai)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	uint32_t cfg;
++
++	if (dai->active)
++		return 0;
++
++	cfg = rt5350_pcm_read(pcm, PCM_REG_CFG0);
++	cfg |= PCM_REG_CFG0_EN;
++	rt5350_pcm_write(pcm, PCM_REG_CFG0, cfg);
++
++	return 0;
++}
++
++static void rt5350_pcm_shutdown(struct snd_pcm_substream *substream,
++	struct snd_soc_dai *dai)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	uint32_t cfg;
++
++	if (dai->active)
++		return;
++
++	cfg = rt5350_pcm_read(pcm, PCM_REG_CFG0);
++	cfg &= ~PCM_REG_CFG0_EN;
++	rt5350_pcm_write(pcm, PCM_REG_CFG0, cfg);
++}
++
++static int rt5350_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
++	struct snd_soc_dai *dai)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++
++	uint32_t cfg;
++	uint32_t mask;
++
++	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++		mask = PCM_REG_CFG0_TX_EN;
++	else
++		mask = PCM_REG_CFG0_RX_EN;
++
++	cfg = rt5350_pcm_read(pcm, PCM_REG_CFG0);
++
++	switch (cmd) {
++	case SNDRV_PCM_TRIGGER_START:
++	case SNDRV_PCM_TRIGGER_RESUME:
++	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
++		cfg |= mask;
++		break;
++	case SNDRV_PCM_TRIGGER_STOP:
++	case SNDRV_PCM_TRIGGER_SUSPEND:
++	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
++		cfg &= ~mask;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	if (cfg & (PCM_REG_CFG0_TX_EN | PCM_REG_CFG0_RX_EN))
++		cfg |= PCM_REG_CFG0_DMA_EN;
++	else
++		cfg &= ~PCM_REG_CFG0_DMA_EN;
++
++	rt5350_pcm_write(pcm, PCM_REG_CFG0, cfg);
++
++	return 0;
++}
++
++static int rt5350_pcm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	uint32_t cfg;
++
++	cfg = rt5350_pcm_read(pcm, PCM_REG_CFG0);
++
++	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
++	case SND_SOC_DAIFMT_CBS_CFS:
++		cfg |= PCM_REG_CFG0_SLAVE;
++		break;
++	case SND_SOC_DAIFMT_CBM_CFM:
++		cfg &= ~PCM_REG_CFG0_SLAVE;
++		break;
++	case SND_SOC_DAIFMT_CBM_CFS:
++	default:
++		return -EINVAL;
++	}
++
++	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
++	case SND_SOC_DAIFMT_PCM:
++	case SND_SOC_DAIFMT_MSB:
++		cfg &= ~PCM_REG_CFG0_BYTE_SWAP;
++		break;
++	case SND_SOC_DAIFMT_LSB:
++		cfg |= PCM_REG_CFG0_BYTE_SWAP;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
++	case SND_SOC_DAIFMT_NB_NF:
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	rt5350_pcm_write(pcm, PCM_REG_CFG0, cfg);
++
++	return 0;
++}
++
++static int rt5350_pcm_hw_params(struct snd_pcm_substream *substream,
++	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
++{
++
++	return 0;
++}
++
++unsigned long pcmMaster_inclk_int[11] = {
++	78,     56,     52,     39,     28,     26,     19,     14,     13,     9,      6};
++unsigned long pcmMaster_inclk_comp[11] = {
++	64,     352,    42,     32,     176,    21,     272,    88,     10,     455,    261};
++
++
++static int rt5350_pcm_set_sysclk(struct snd_soc_dai *dai, int clk_id,
++	unsigned int freq, int dir)
++{
++        struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++
++	printk("Internal REFCLK with fractional division\n");
++
++	rt5350_pcm_write(pcm, PCM_REG_DIVINT, pcmMaster_inclk_int[7]);
++	rt5350_pcm_write(pcm, PCM_REG_DIVCMP,
++		pcmMaster_inclk_comp[7] | PCM_REG_CLK_EN);
++
++/*	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	struct clk *parent;
++	int ret = 0;
++
++	switch (clk_id) {
++	case RT5350_PCM_CLKSRC_EXT:
++		parent = clk_get(NULL, "ext");
++		clk_set_parent(pcm->clk_pcm, parent);
++		break;
++	case RT5350_PCM_CLKSRC_PLL:
++		parent = clk_get(NULL, "pll half");
++		clk_set_parent(pcm->clk_pcm, parent);
++		ret = clk_set_rate(pcm->clk_pcm, freq);
++		break;
++	default:
++		return -EINVAL;
++	}
++	clk_put(parent);
++
++	return ret;*/
++	return 0;
++}
++
++static int rt5350_pcm_suspend(struct snd_soc_dai *dai)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	uint32_t cfg;
++
++	if (dai->active) {
++		cfg = rt5350_pcm_read(pcm, PCM_REG_CFG0);
++		cfg &= ~PCM_REG_CFG0_TX_EN;
++		rt5350_pcm_write(pcm, PCM_REG_CFG0, cfg);
++	}
++
++	return 0;
++}
++
++static int rt5350_pcm_resume(struct snd_soc_dai *dai)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	uint32_t cfg;
++
++	if (dai->active) {
++		cfg = rt5350_pcm_read(pcm, PCM_REG_CFG0);
++		cfg |= PCM_REG_CFG0_TX_EN;
++		rt5350_pcm_write(pcm, PCM_REG_CFG0, cfg);
++	}
++
++	return 0;
++}
++
++static void rt5350_i2c_init_pcm_config(struct rt5350_pcm *pcm)
++{
++	struct snd_dmaengine_dai_dma_data *dma_data;
++
++	/* Playback */
++	dma_data = &pcm->playback_dma_data;
++	dma_data->maxburst = 16;
++	dma_data->slave_id = 2; //RT5350_DMA_TYPE_AIC_TRANSMIT;
++	dma_data->addr = pcm->phys_base + PCM_REG_WREG;
++
++	/* Capture */
++	dma_data = &pcm->capture_dma_data;
++	dma_data->maxburst = 16;
++	dma_data->slave_id = 3; //RT5350_DMA_TYPE_AIC_RECEIVE;
++	dma_data->addr = pcm->phys_base + PCM_REG_RREG;
++}
++
++static int rt5350_pcm_dai_probe(struct snd_soc_dai *dai)
++{
++	struct rt5350_pcm *pcm = snd_soc_dai_get_drvdata(dai);
++	uint32_t data;
++
++	rt5350_i2c_init_pcm_config(pcm);
++	dai->playback_dma_data = &pcm->playback_dma_data;
++	dai->capture_dma_data = &pcm->capture_dma_data;
++
++	/* set share pins to pcm/gpio mode and i2c mode */
++	data = rt_sysc_r32(0x60);
++	data &= 0xFFFFFFE2;
++	data |= 0x00000018;
++	rt_sysc_w32(data, 0x60);
++
++	printk("Internal REFCLK with fractional division\n");
++
++	rt5350_pcm_write(pcm, PCM_REG_CFG0, PCM_REG_CFG0_DFT_THRES);
++	rt5350_pcm_write(pcm, PCM_REG_CFG1, 0);
++	rt5350_pcm_write(pcm, PCM_REG_INT_EN, 0);
++
++	rt5350_pcm_write(pcm, PCM_REG_DIVINT, pcmMaster_inclk_int[7]);
++	rt5350_pcm_write(pcm, PCM_REG_DIVCMP,
++		pcmMaster_inclk_comp[7] | PCM_REG_CLK_EN);
++
++	return 0;
++}
++
++static int rt5350_pcm_dai_remove(struct snd_soc_dai *dai)
++{
++	return 0;
++}
++
++static const struct snd_soc_dai_ops rt5350_pcm_dai_ops = {
++	.startup = rt5350_pcm_startup,
++	.shutdown = rt5350_pcm_shutdown,
++	.trigger = rt5350_pcm_trigger,
++	.hw_params = rt5350_pcm_hw_params,
++	.set_fmt = rt5350_pcm_set_fmt,
++	.set_sysclk = rt5350_pcm_set_sysclk,
++};
++
++#define RT5350_PCM_FMTS (SNDRV_PCM_FMTBIT_S8 | \
++		SNDRV_PCM_FMTBIT_S16_LE)
++
++static struct snd_soc_dai_driver rt5350_pcm_dai = {
++	.probe = rt5350_pcm_dai_probe,
++	.remove = rt5350_pcm_dai_remove,
++	.playback = {
++		.channels_min = 1,
++		.channels_max = 2,
++		.rates = SNDRV_PCM_RATE_8000_48000,
++		.formats = RT5350_PCM_FMTS,
++	},
++	.capture = {
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = SNDRV_PCM_RATE_8000_48000,
++		.formats = RT5350_PCM_FMTS,
++	},
++	.symmetric_rates = 1,
++	.ops = &rt5350_pcm_dai_ops,
++	.suspend = rt5350_pcm_suspend,
++	.resume = rt5350_pcm_resume,
++};
++
++static const struct snd_pcm_hardware rt5350_pcm_hardware = {
++	.info = SNDRV_PCM_INFO_MMAP |
++		SNDRV_PCM_INFO_MMAP_VALID |
++		SNDRV_PCM_INFO_INTERLEAVED |
++		SNDRV_PCM_INFO_BLOCK_TRANSFER,
++	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8,
++	.period_bytes_min	= PAGE_SIZE,
++	.period_bytes_max	= 64 * 1024,
++	.periods_min		= 2,
++	.periods_max		= 128,
++	.buffer_bytes_max	= 128 * 1024,
++	.fifo_size		= 32,
++};
++
++static const struct snd_dmaengine_pcm_config rt5350_dmaengine_pcm_config = {
++	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
++	.pcm_hardware = &rt5350_pcm_hardware,
++	.prealloc_buffer_size = 256 * PAGE_SIZE,
++};
++
++static const struct snd_soc_component_driver rt5350_pcm_component = {
++	.name = "rt5350-pcm",
++};
++
++static int rt5350_pcm_dev_probe(struct platform_device *pdev)
++{
++	struct rt5350_pcm *pcm;
++	int ret;
++
++	snd_dmaengine_pcm_register(&pdev->dev,
++		&rt5350_dmaengine_pcm_config,
++		SND_DMAENGINE_PCM_FLAG_COMPAT);
++
++	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
++	if (!pcm)
++		return -ENOMEM;
++
++	pcm->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!pcm->mem) {
++		ret = -ENOENT;
++		goto err_free;
++	}
++
++	pcm->mem = request_mem_region(pcm->mem->start, resource_size(pcm->mem),
++				pdev->name);
++	if (!pcm->mem) {
++		ret = -EBUSY;
++		goto err_free;
++	}
++
++	pcm->base = ioremap_nocache(pcm->mem->start, resource_size(pcm->mem));
++	if (!pcm->base) {
++		ret = -EBUSY;
++		goto err_release_mem_region;
++	}
++
++	pcm->phys_base = pcm->mem->start;
++
++	platform_set_drvdata(pdev, pcm);
++	ret = snd_soc_register_component(&pdev->dev, &rt5350_pcm_component,
++					 &rt5350_pcm_dai, 1);
++
++	if (!ret) {
++		dev_err(&pdev->dev, "loaded\n");
++		return ret;
++	}
++
++	dev_err(&pdev->dev, "Failed to register DAI\n");
++	iounmap(pcm->base);
++
++err_release_mem_region:
++	release_mem_region(pcm->mem->start, resource_size(pcm->mem));
++err_free:
++	kfree(pcm);
++
++	return ret;
++}
++
++static int rt5350_pcm_dev_remove(struct platform_device *pdev)
++{
++	struct rt5350_pcm *pcm = platform_get_drvdata(pdev);
++
++	snd_soc_unregister_component(&pdev->dev);
++
++	iounmap(pcm->base);
++	release_mem_region(pcm->mem->start, resource_size(pcm->mem));
++
++	kfree(pcm);
++
++	snd_dmaengine_pcm_unregister(&pdev->dev);
++
++	return 0;
++}
++
++static const struct of_device_id rt5350_pcm_match[] = {
++	{ .compatible = "ralink,rt5350a-pcm" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, rt5350_pcm_match);
++
++static struct platform_driver rt5350_pcm_driver = {
++	.probe = rt5350_pcm_dev_probe,
++	.remove = rt5350_pcm_dev_remove,
++	.driver = {
++		.name = "rt5350-pcm",
++		.owner = THIS_MODULE,
++		.of_match_table = rt5350_pcm_match,
++	},
++};
++
++module_platform_driver(rt5350_pcm_driver);
++
++MODULE_AUTHOR("Lars-Peter Clausen, <lars@metafoo.de>");
++MODULE_DESCRIPTION("Ralink RT5350 SoC PCM driver");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:rt5350-pcm");
diff --git a/target/linux/ramips/rt305x/profiles/asiarf.mk b/target/linux/ramips/rt305x/profiles/asiarf.mk
index 8b1f757..94dc2f5 100644
--- a/target/linux/ramips/rt305x/profiles/asiarf.mk
+++ b/target/linux/ramips/rt305x/profiles/asiarf.mk
@@ -16,3 +16,15 @@ define Profile/AWM002EVB/Description
 endef
 
 $(eval $(call Profile,AWM002EVB))
+
+define Profile/ZARLINK
+	NAME:=AsiaRF Zarlink
+	PACKAGES:=kmod-usb-core kmod-usb-ohci kmod-usb2 kmod-ledtrig-usbdev \
+	kmod-i2c-core kmod-i2c-gpio
+endef
+
+define Profile/ZARLINK/Description
+	Package set for AsiaRF Zarlink
+endef
+
+$(eval $(call Profile,ZARLINK))

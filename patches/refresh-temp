Bottom: fc65b77cc3cba8c6d4a21a5c970de9ff048ceafd
Top:    2903221850dbc369b3e1cbf3f43ee254b9ae79b2
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-01-01 15:50:52 -0500

Refresh of zarlink

---

diff --git a/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch b/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
index a4fc7b4..ac18c7f 100644
--- a/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
+++ b/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
@@ -1,12 +1,13 @@
 --- /dev/null
 +++ b/sound/soc/codecs/le89156.c
-@@ -0,0 +1,1101 @@
+@@ -0,0 +1,574 @@
 +/*
 + * le89156.c  --  LE89156 ALSA SoC Audio driver
 + *
-+ * Copyright 2007-11 Wolfson Microelectronics, plc
++ * Copyright 2010-1 Wolfson Microelectronics plc
++ *
++ * Author: Ian Lartey <ian@opensource.wolfsonmicro.com>
 + *
-+ * Author: Liam Girdwood
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
@@ -18,1095 +19,573 @@
 +#include <linux/init.h>
 +#include <linux/delay.h>
 +#include <linux/pm.h>
-+#include <linux/i2c.h>
++#include <linux/spi/spi.h>
++#include <linux/regmap.h>
++#include <linux/regulator/consumer.h>
 +#include <linux/slab.h>
++#include <linux/of_device.h>
 +#include <sound/core.h>
 +#include <sound/pcm.h>
 +#include <sound/pcm_params.h>
 +#include <sound/soc.h>
 +#include <sound/initval.h>
 +#include <sound/tlv.h>
-+#include <sound/le89156.h>
 +
 +#include "le89156.h"
 +
-+/* R25 - Power 1 */
-+#define LE89156_VMID_MASK 0x180
-+#define LE89156_VREF      0x40
-+
-+/* R26 - Power 2 */
-+#define LE89156_PWR2_LOUT1	0x40
-+#define LE89156_PWR2_ROUT1	0x20
-+#define LE89156_PWR2_OUT3	0x02
++#define LE89156_NUM_SUPPLIES 2
++static const char *le89156_supply_names[LE89156_NUM_SUPPLIES] = {
++	"AVDD",
++	"DVDD",
++};
 +
-+/* R28 - Anti-pop 1 */
-+#define LE89156_POBCTRL   0x80
-+#define LE89156_BUFDCOPEN 0x10
-+#define LE89156_BUFIOEN   0x08
-+#define LE89156_SOFT_ST   0x04
-+#define LE89156_HPSTBY    0x01
++#define LE89156_NUM_RATES 6
 +
-+/* R29 - Anti-pop 2 */
-+#define LE89156_DISOP     0x40
-+#define LE89156_DRES_MASK 0x30
++/* codec private data */
++struct le89156_priv {
++	struct regmap *regmap;
++	struct regulator_bulk_data supplies[LE89156_NUM_SUPPLIES];
++	unsigned int sysclk;
++	struct snd_pcm_hw_constraint_list *sysclk_constraints;
++};
 +
-+/*
-+ * le89156 register cache
-+ * We can't read the LE89156 register space when we are
-+ * using 2 wire for device control, so we cache them instead.
-+ */
 +static const struct reg_default le89156_reg_defaults[] = {
-+	{  0x0, 0x00a7 },
-+	{  0x1, 0x00a7 },
-+	{  0x2, 0x0000 },
-+	{  0x3, 0x0000 },
-+	{  0x4, 0x0000 },
-+	{  0x5, 0x0008 },
-+	{  0x6, 0x0000 },
-+	{  0x7, 0x000a },
-+	{  0x8, 0x01c0 },
-+	{  0x9, 0x0000 },
-+	{  0xa, 0x00ff },
-+	{  0xb, 0x00ff },
-+
-+	{ 0x10, 0x0000 },
-+	{ 0x11, 0x007b },
-+	{ 0x12, 0x0100 },
-+	{ 0x13, 0x0032 },
-+	{ 0x14, 0x0000 },
-+	{ 0x15, 0x00c3 },
-+	{ 0x16, 0x00c3 },
-+	{ 0x17, 0x01c0 },
-+	{ 0x18, 0x0000 },
-+	{ 0x19, 0x0000 },
-+	{ 0x1a, 0x0000 },
-+	{ 0x1b, 0x0000 },
-+	{ 0x1c, 0x0000 },
-+	{ 0x1d, 0x0000 },
-+
-+	{ 0x20, 0x0100 },
-+	{ 0x21, 0x0100 },
-+	{ 0x22, 0x0050 },
-+
-+	{ 0x25, 0x0050 },
-+	{ 0x26, 0x0000 },
-+	{ 0x27, 0x0000 },
-+	{ 0x28, 0x0000 },
-+	{ 0x29, 0x0000 },
-+	{ 0x2a, 0x0040 },
-+	{ 0x2b, 0x0000 },
-+	{ 0x2c, 0x0000 },
-+	{ 0x2d, 0x0050 },
-+	{ 0x2e, 0x0050 },
-+	{ 0x2f, 0x0000 },
-+	{ 0x30, 0x0002 },
-+	{ 0x31, 0x0037 },
-+
-+	{ 0x33, 0x0080 },
-+	{ 0x34, 0x0008 },
-+	{ 0x35, 0x0031 },
-+	{ 0x36, 0x0026 },
-+	{ 0x37, 0x00e9 },
++	{  0, 0x0000 },     /* R0  - DACLLSB Attenuation */
++	{  1, 0x0000 },     /* R1  - DACLMSB Attenuation */
++	{  2, 0x0000 },     /* R2  - DACRLSB Attenuation */
++	{  3, 0x0000 },     /* R3  - DACRMSB Attenuation */
++	{  4, 0x0000 },     /* R4  - Volume Control */
++	{  5, 0x000A },     /* R5  - Format Control */
++	{  6, 0x0000 },     /* R6  - Filter Control */
++	{  7, 0x0000 },     /* R7  - Mode Control 1 */
++	{  8, 0x0002 },     /* R8  - Mode Control 2 */
++	{ 32, 0x0002 },     /* R32 - ADDITONAL_CONTROL_1 */
 +};
 +
-+static bool le89156_volatile(struct device *dev, unsigned int reg)
++static bool le89156_readable(struct device *dev, unsigned int reg)
 +{
 +	switch (reg) {
-+	case LE89156_RESET:
++	case LE89156_DACLLSB_ATTENUATION:
++	case LE89156_DACLMSB_ATTENUATION:
++	case LE89156_DACRLSB_ATTENUATION:
++	case LE89156_DACRMSB_ATTENUATION:
++	case LE89156_VOLUME_CONTROL:
++	case LE89156_FORMAT_CONTROL:
++	case LE89156_FILTER_CONTROL:
++	case LE89156_MODE_CONTROL_1:
++	case LE89156_MODE_CONTROL_2:
++	case LE89156_ADDITIONAL_CONTROL_1:
 +		return true;
 +	default:
 +		return false;
 +	}
 +}
 +
-+struct le89156_priv {
-+	struct regmap *regmap;
-+	int (*set_bias_level)(struct snd_soc_codec *,
-+			      enum snd_soc_bias_level level);
-+	struct snd_soc_dapm_widget *lout1;
-+	struct snd_soc_dapm_widget *rout1;
-+	struct snd_soc_dapm_widget *out3;
-+	bool deemph;
-+	int playback_fs;
-+};
-+
-+#define le89156_reset(c)	snd_soc_write(c, LE89156_RESET, 0)
-+
-+/* enumerated controls */
-+static const char *le89156_polarity[] = {"No Inversion", "Left Inverted",
-+	"Right Inverted", "Stereo Inversion"};
-+static const char *le89156_3d_upper_cutoff[] = {"High", "Low"};
-+static const char *le89156_3d_lower_cutoff[] = {"Low", "High"};
-+static const char *le89156_alcfunc[] = {"Off", "Right", "Left", "Stereo"};
-+static const char *le89156_alcmode[] = {"ALC", "Limiter"};
-+
-+static const struct soc_enum le89156_enum[] = {
-+	SOC_ENUM_SINGLE(LE89156_DACCTL1, 5, 4, le89156_polarity),
-+	SOC_ENUM_SINGLE(LE89156_DACCTL2, 5, 4, le89156_polarity),
-+	SOC_ENUM_SINGLE(LE89156_3D, 6, 2, le89156_3d_upper_cutoff),
-+	SOC_ENUM_SINGLE(LE89156_3D, 5, 2, le89156_3d_lower_cutoff),
-+	SOC_ENUM_SINGLE(LE89156_ALC1, 7, 4, le89156_alcfunc),
-+	SOC_ENUM_SINGLE(LE89156_ALC3, 8, 2, le89156_alcmode),
-+};
-+
-+static const int deemph_settings[] = { 0, 32000, 44100, 48000 };
-+
-+static int le89156_set_deemph(struct snd_soc_codec *codec)
-+{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	int val, i, best;
-+
-+	/* If we're using deemphasis select the nearest available sample
-+	 * rate.
-+	 */
-+	if (le89156->deemph) {
-+		best = 1;
-+		for (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {
-+			if (abs(deemph_settings[i] - le89156->playback_fs) <
-+			    abs(deemph_settings[best] - le89156->playback_fs))
-+				best = i;
-+		}
-+
-+		val = best << 1;
-+	} else {
-+		val = 0;
-+	}
-+
-+	dev_dbg(codec->dev, "Set deemphasis %d\n", val);
-+
-+	return snd_soc_update_bits(codec, LE89156_DACCTL1,
-+				   0x6, val);
-+}
-+
-+static int le89156_get_deemph(struct snd_kcontrol *kcontrol,
-+			     struct snd_ctl_elem_value *ucontrol)
++static int le89156_reset(struct snd_soc_codec *codec)
 +{
-+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+
-+	ucontrol->value.enumerated.item[0] = le89156->deemph;
-+	return 0;
++	return snd_soc_write(codec, LE89156_RESET, 0);
 +}
 +
-+static int le89156_put_deemph(struct snd_kcontrol *kcontrol,
-+			     struct snd_ctl_elem_value *ucontrol)
-+{
-+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	int deemph = ucontrol->value.enumerated.item[0];
-+
-+	if (deemph > 1)
-+		return -EINVAL;
-+
-+	le89156->deemph = deemph;
-+
-+	return le89156_set_deemph(codec);
-+}
-+
-+static const DECLARE_TLV_DB_SCALE(adc_tlv, -9700, 50, 0);
-+static const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 50, 1);
-+static const DECLARE_TLV_DB_SCALE(bypass_tlv, -2100, 300, 0);
-+static const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);
-+static const DECLARE_TLV_DB_SCALE(boost_tlv, -1200, 300, 1);
++static const DECLARE_TLV_DB_SCALE(dac_tlv_fine, -12700, 13, 0);
++static const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 400, 0);
 +
 +static const struct snd_kcontrol_new le89156_snd_controls[] = {
-+SOC_DOUBLE_R_TLV("Capture Volume", LE89156_LINVOL, LE89156_RINVOL,
-+		 0, 63, 0, adc_tlv),
-+SOC_DOUBLE_R("Capture Volume ZC Switch", LE89156_LINVOL, LE89156_RINVOL,
-+	6, 1, 0),
-+SOC_DOUBLE_R("Capture Switch", LE89156_LINVOL, LE89156_RINVOL,
-+	7, 1, 0),
-+
-+SOC_SINGLE_TLV("Right Input Boost Mixer RINPUT3 Volume",
-+	       LE89156_INBMIX1, 4, 7, 0, boost_tlv),
-+SOC_SINGLE_TLV("Right Input Boost Mixer RINPUT2 Volume",
-+	       LE89156_INBMIX1, 1, 7, 0, boost_tlv),
-+SOC_SINGLE_TLV("Left Input Boost Mixer LINPUT3 Volume",
-+	       LE89156_INBMIX2, 4, 7, 0, boost_tlv),
-+SOC_SINGLE_TLV("Left Input Boost Mixer LINPUT2 Volume",
-+	       LE89156_INBMIX2, 1, 7, 0, boost_tlv),
-+
-+SOC_DOUBLE_R_TLV("Playback Volume", LE89156_LDAC, LE89156_RDAC,
-+		 0, 255, 0, dac_tlv),
-+
-+SOC_DOUBLE_R_TLV("Headphone Playback Volume", LE89156_LOUT1, LE89156_ROUT1,
-+		 0, 127, 0, out_tlv),
-+SOC_DOUBLE_R("Headphone Playback ZC Switch", LE89156_LOUT1, LE89156_ROUT1,
-+	7, 1, 0),
-+
-+SOC_DOUBLE_R_TLV("Speaker Playback Volume", LE89156_LOUT2, LE89156_ROUT2,
-+		 0, 127, 0, out_tlv),
-+SOC_DOUBLE_R("Speaker Playback ZC Switch", LE89156_LOUT2, LE89156_ROUT2,
-+	7, 1, 0),
-+SOC_SINGLE("Speaker DC Volume", LE89156_CLASSD3, 3, 5, 0),
-+SOC_SINGLE("Speaker AC Volume", LE89156_CLASSD3, 0, 5, 0),
-+
-+SOC_SINGLE("PCM Playback -6dB Switch", LE89156_DACCTL1, 7, 1, 0),
-+SOC_ENUM("ADC Polarity", le89156_enum[0]),
-+SOC_SINGLE("ADC High Pass Filter Switch", LE89156_DACCTL1, 0, 1, 0),
-+
-+SOC_ENUM("DAC Polarity", le89156_enum[2]),
-+SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
-+		    le89156_get_deemph, le89156_put_deemph),
-+
-+SOC_ENUM("3D Filter Upper Cut-Off", le89156_enum[2]),
-+SOC_ENUM("3D Filter Lower Cut-Off", le89156_enum[3]),
-+SOC_SINGLE("3D Volume", LE89156_3D, 1, 15, 0),
-+SOC_SINGLE("3D Switch", LE89156_3D, 0, 1, 0),
-+
-+SOC_ENUM("ALC Function", le89156_enum[4]),
-+SOC_SINGLE("ALC Max Gain", LE89156_ALC1, 4, 7, 0),
-+SOC_SINGLE("ALC Target", LE89156_ALC1, 0, 15, 1),
-+SOC_SINGLE("ALC Min Gain", LE89156_ALC2, 4, 7, 0),
-+SOC_SINGLE("ALC Hold Time", LE89156_ALC2, 0, 15, 0),
-+SOC_ENUM("ALC Mode", le89156_enum[5]),
-+SOC_SINGLE("ALC Decay", LE89156_ALC3, 4, 15, 0),
-+SOC_SINGLE("ALC Attack", LE89156_ALC3, 0, 15, 0),
-+
-+SOC_SINGLE("Noise Gate Threshold", LE89156_NOISEG, 3, 31, 0),
-+SOC_SINGLE("Noise Gate Switch", LE89156_NOISEG, 0, 1, 0),
-+
-+SOC_DOUBLE_R("ADC PCM Capture Volume", LE89156_LINPATH, LE89156_RINPATH,
-+	0, 127, 0),
-+
-+SOC_SINGLE_TLV("Left Output Mixer Boost Bypass Volume",
-+	       LE89156_BYPASS1, 4, 7, 1, bypass_tlv),
-+SOC_SINGLE_TLV("Left Output Mixer LINPUT3 Volume",
-+	       LE89156_LOUTMIX, 4, 7, 1, bypass_tlv),
-+SOC_SINGLE_TLV("Right Output Mixer Boost Bypass Volume",
-+	       LE89156_BYPASS2, 4, 7, 1, bypass_tlv),
-+SOC_SINGLE_TLV("Right Output Mixer RINPUT3 Volume",
-+	       LE89156_ROUTMIX, 4, 7, 1, bypass_tlv),
++SOC_DOUBLE_R_TLV("Fine Playback Volume", LE89156_DACLLSB_ATTENUATION,
++		 LE89156_DACRLSB_ATTENUATION, 1, 255, 1, dac_tlv_fine),
++SOC_DOUBLE_R_TLV("Playback Volume", LE89156_DACLMSB_ATTENUATION,
++		 LE89156_DACRMSB_ATTENUATION, 0, 511, 1, dac_tlv),
 +};
 +
-+static const struct snd_kcontrol_new le89156_lin_boost[] = {
-+SOC_DAPM_SINGLE("LINPUT2 Switch", LE89156_LINPATH, 6, 1, 0),
-+SOC_DAPM_SINGLE("LINPUT3 Switch", LE89156_LINPATH, 7, 1, 0),
-+SOC_DAPM_SINGLE("LINPUT1 Switch", LE89156_LINPATH, 8, 1, 0),
++static const struct snd_soc_dapm_widget le89156_dapm_widgets[] = {
++SND_SOC_DAPM_DAC("DACL", "Playback", SND_SOC_NOPM, 0, 0),
++SND_SOC_DAPM_DAC("DACR", "Playback", SND_SOC_NOPM, 0, 0),
++SND_SOC_DAPM_OUTPUT("VOUTLP"),
++SND_SOC_DAPM_OUTPUT("VOUTLN"),
++SND_SOC_DAPM_OUTPUT("VOUTRP"),
++SND_SOC_DAPM_OUTPUT("VOUTRN"),
 +};
 +
-+static const struct snd_kcontrol_new le89156_lin[] = {
-+SOC_DAPM_SINGLE("Boost Switch", LE89156_LINPATH, 3, 1, 0),
++static const struct snd_soc_dapm_route le89156_dapm_routes[] = {
++	{ "VOUTLP", NULL, "DACL" },
++	{ "VOUTLN", NULL, "DACL" },
++	{ "VOUTRP", NULL, "DACR" },
++	{ "VOUTRN", NULL, "DACR" },
 +};
 +
-+static const struct snd_kcontrol_new le89156_rin_boost[] = {
-+SOC_DAPM_SINGLE("RINPUT2 Switch", LE89156_RINPATH, 6, 1, 0),
-+SOC_DAPM_SINGLE("RINPUT3 Switch", LE89156_RINPATH, 7, 1, 0),
-+SOC_DAPM_SINGLE("RINPUT1 Switch", LE89156_RINPATH, 8, 1, 0),
++static struct {
++	int value;
++	int ratio;
++} lrclk_ratios[LE89156_NUM_RATES] = {
++	{ 1, 128 },
++	{ 2, 192 },
++	{ 3, 256 },
++	{ 4, 384 },
++	{ 5, 512 },
++	{ 6, 768 },
 +};
 +
-+static const struct snd_kcontrol_new le89156_rin[] = {
-+SOC_DAPM_SINGLE("Boost Switch", LE89156_RINPATH, 3, 1, 0),
++static unsigned int rates_11289[] = {
++	44100, 88235,
 +};
 +
-+static const struct snd_kcontrol_new le89156_loutput_mixer[] = {
-+SOC_DAPM_SINGLE("PCM Playback Switch", LE89156_LOUTMIX, 8, 1, 0),
-+SOC_DAPM_SINGLE("LINPUT3 Switch", LE89156_LOUTMIX, 7, 1, 0),
-+SOC_DAPM_SINGLE("Boost Bypass Switch", LE89156_BYPASS1, 7, 1, 0),
++static struct snd_pcm_hw_constraint_list constraints_11289 = {
++	.count	= ARRAY_SIZE(rates_11289),
++	.list	= rates_11289,
 +};
 +
-+static const struct snd_kcontrol_new le89156_routput_mixer[] = {
-+SOC_DAPM_SINGLE("PCM Playback Switch", LE89156_ROUTMIX, 8, 1, 0),
-+SOC_DAPM_SINGLE("RINPUT3 Switch", LE89156_ROUTMIX, 7, 1, 0),
-+SOC_DAPM_SINGLE("Boost Bypass Switch", LE89156_BYPASS2, 7, 1, 0),
++static unsigned int rates_12288[] = {
++	32000, 48000, 96000,
 +};
 +
-+static const struct snd_kcontrol_new le89156_mono_out[] = {
-+SOC_DAPM_SINGLE("Left Switch", LE89156_MONOMIX1, 7, 1, 0),
-+SOC_DAPM_SINGLE("Right Switch", LE89156_MONOMIX2, 7, 1, 0),
++static struct snd_pcm_hw_constraint_list constraints_12288 = {
++	.count	= ARRAY_SIZE(rates_12288),
++	.list	= rates_12288,
 +};
 +
-+static const struct snd_soc_dapm_widget le89156_dapm_widgets[] = {
-+SND_SOC_DAPM_INPUT("LINPUT1"),
-+SND_SOC_DAPM_INPUT("RINPUT1"),
-+SND_SOC_DAPM_INPUT("LINPUT2"),
-+SND_SOC_DAPM_INPUT("RINPUT2"),
-+SND_SOC_DAPM_INPUT("LINPUT3"),
-+SND_SOC_DAPM_INPUT("RINPUT3"),
-+
-+SND_SOC_DAPM_SUPPLY("MICB", LE89156_POWER1, 1, 0, NULL, 0),
-+
-+SND_SOC_DAPM_MIXER("Left Boost Mixer", LE89156_POWER1, 5, 0,
-+		   le89156_lin_boost, ARRAY_SIZE(le89156_lin_boost)),
-+SND_SOC_DAPM_MIXER("Right Boost Mixer", LE89156_POWER1, 4, 0,
-+		   le89156_rin_boost, ARRAY_SIZE(le89156_rin_boost)),
-+
-+SND_SOC_DAPM_MIXER("Left Input Mixer", LE89156_POWER3, 5, 0,
-+		   le89156_lin, ARRAY_SIZE(le89156_lin)),
-+SND_SOC_DAPM_MIXER("Right Input Mixer", LE89156_POWER3, 4, 0,
-+		   le89156_rin, ARRAY_SIZE(le89156_rin)),
-+
-+SND_SOC_DAPM_ADC("Left ADC", "Capture", LE89156_POWER1, 3, 0),
-+SND_SOC_DAPM_ADC("Right ADC", "Capture", LE89156_POWER1, 2, 0),
-+
-+SND_SOC_DAPM_DAC("Left DAC", "Playback", LE89156_POWER2, 8, 0),
-+SND_SOC_DAPM_DAC("Right DAC", "Playback", LE89156_POWER2, 7, 0),
-+
-+SND_SOC_DAPM_MIXER("Left Output Mixer", LE89156_POWER3, 3, 0,
-+	&le89156_loutput_mixer[0],
-+	ARRAY_SIZE(le89156_loutput_mixer)),
-+SND_SOC_DAPM_MIXER("Right Output Mixer", LE89156_POWER3, 2, 0,
-+	&le89156_routput_mixer[0],
-+	ARRAY_SIZE(le89156_routput_mixer)),
-+
-+SND_SOC_DAPM_PGA("LOUT1 PGA", LE89156_POWER2, 6, 0, NULL, 0),
-+SND_SOC_DAPM_PGA("ROUT1 PGA", LE89156_POWER2, 5, 0, NULL, 0),
-+
-+SND_SOC_DAPM_PGA("Left Speaker PGA", LE89156_POWER2, 4, 0, NULL, 0),
-+SND_SOC_DAPM_PGA("Right Speaker PGA", LE89156_POWER2, 3, 0, NULL, 0),
-+
-+SND_SOC_DAPM_PGA("Right Speaker Output", LE89156_CLASSD1, 7, 0, NULL, 0),
-+SND_SOC_DAPM_PGA("Left Speaker Output", LE89156_CLASSD1, 6, 0, NULL, 0),
-+
-+SND_SOC_DAPM_OUTPUT("SPK_LP"),
-+SND_SOC_DAPM_OUTPUT("SPK_LN"),
-+SND_SOC_DAPM_OUTPUT("HP_L"),
-+SND_SOC_DAPM_OUTPUT("HP_R"),
-+SND_SOC_DAPM_OUTPUT("SPK_RP"),
-+SND_SOC_DAPM_OUTPUT("SPK_RN"),
-+SND_SOC_DAPM_OUTPUT("OUT3"),
++static unsigned int rates_16384[] = {
++	32000,
 +};
 +
-+static const struct snd_soc_dapm_widget le89156_dapm_widgets_out3[] = {
-+SND_SOC_DAPM_MIXER("Mono Output Mixer", LE89156_POWER2, 1, 0,
-+	&le89156_mono_out[0],
-+	ARRAY_SIZE(le89156_mono_out)),
++static struct snd_pcm_hw_constraint_list constraints_16384 = {
++	.count	= ARRAY_SIZE(rates_16384),
++	.list	= rates_16384,
 +};
 +
-+/* Represent OUT3 as a PGA so that it gets turned on with LOUT1/ROUT1 */
-+static const struct snd_soc_dapm_widget le89156_dapm_widgets_capless[] = {
-+SND_SOC_DAPM_PGA("OUT3 VMID", LE89156_POWER2, 1, 0, NULL, 0),
++static unsigned int rates_16934[] = {
++	44100, 88235,
 +};
 +
-+static const struct snd_soc_dapm_route audio_paths[] = {
-+	{ "Left Boost Mixer", "LINPUT1 Switch", "LINPUT1" },
-+	{ "Left Boost Mixer", "LINPUT2 Switch", "LINPUT2" },
-+	{ "Left Boost Mixer", "LINPUT3 Switch", "LINPUT3" },
-+
-+	{ "Left Input Mixer", "Boost Switch", "Left Boost Mixer", },
-+	{ "Left Input Mixer", NULL, "LINPUT1", },  /* Really Boost Switch */
-+	{ "Left Input Mixer", NULL, "LINPUT2" },
-+	{ "Left Input Mixer", NULL, "LINPUT3" },
-+
-+	{ "Right Boost Mixer", "RINPUT1 Switch", "RINPUT1" },
-+	{ "Right Boost Mixer", "RINPUT2 Switch", "RINPUT2" },
-+	{ "Right Boost Mixer", "RINPUT3 Switch", "RINPUT3" },
-+
-+	{ "Right Input Mixer", "Boost Switch", "Right Boost Mixer", },
-+	{ "Right Input Mixer", NULL, "RINPUT1", },  /* Really Boost Switch */
-+	{ "Right Input Mixer", NULL, "RINPUT2" },
-+	{ "Right Input Mixer", NULL, "LINPUT3" },
-+
-+	{ "Left ADC", NULL, "Left Input Mixer" },
-+	{ "Right ADC", NULL, "Right Input Mixer" },
-+
-+	{ "Left Output Mixer", "LINPUT3 Switch", "LINPUT3" },
-+	{ "Left Output Mixer", "Boost Bypass Switch", "Left Boost Mixer"} ,
-+	{ "Left Output Mixer", "PCM Playback Switch", "Left DAC" },
-+
-+	{ "Right Output Mixer", "RINPUT3 Switch", "RINPUT3" },
-+	{ "Right Output Mixer", "Boost Bypass Switch", "Right Boost Mixer" } ,
-+	{ "Right Output Mixer", "PCM Playback Switch", "Right DAC" },
-+
-+	{ "LOUT1 PGA", NULL, "Left Output Mixer" },
-+	{ "ROUT1 PGA", NULL, "Right Output Mixer" },
++static struct snd_pcm_hw_constraint_list constraints_16934 = {
++	.count	= ARRAY_SIZE(rates_16934),
++	.list	= rates_16934,
++};
 +
-+	{ "HP_L", NULL, "LOUT1 PGA" },
-+	{ "HP_R", NULL, "ROUT1 PGA" },
++static unsigned int rates_18432[] = {
++	48000, 96000,
++};
 +
-+	{ "Left Speaker PGA", NULL, "Left Output Mixer" },
-+	{ "Right Speaker PGA", NULL, "Right Output Mixer" },
++static struct snd_pcm_hw_constraint_list constraints_18432 = {
++	.count	= ARRAY_SIZE(rates_18432),
++	.list	= rates_18432,
++};
 +
-+	{ "Left Speaker Output", NULL, "Left Speaker PGA" },
-+	{ "Right Speaker Output", NULL, "Right Speaker PGA" },
++static unsigned int rates_22579[] = {
++	44100, 88235, 1764000
++};
 +
-+	{ "SPK_LN", NULL, "Left Speaker Output" },
-+	{ "SPK_LP", NULL, "Left Speaker Output" },
-+	{ "SPK_RN", NULL, "Right Speaker Output" },
-+	{ "SPK_RP", NULL, "Right Speaker Output" },
++static struct snd_pcm_hw_constraint_list constraints_22579 = {
++	.count	= ARRAY_SIZE(rates_22579),
++	.list	= rates_22579,
 +};
 +
-+static const struct snd_soc_dapm_route audio_paths_out3[] = {
-+	{ "Mono Output Mixer", "Left Switch", "Left Output Mixer" },
-+	{ "Mono Output Mixer", "Right Switch", "Right Output Mixer" },
++static unsigned int rates_24576[] = {
++	32000, 48000, 96000, 192000
++};
 +
-+	{ "OUT3", NULL, "Mono Output Mixer", }
++static struct snd_pcm_hw_constraint_list constraints_24576 = {
++	.count	= ARRAY_SIZE(rates_24576),
++	.list	= rates_24576,
 +};
 +
-+static const struct snd_soc_dapm_route audio_paths_capless[] = {
-+	{ "HP_L", NULL, "OUT3 VMID" },
-+	{ "HP_R", NULL, "OUT3 VMID" },
++static unsigned int rates_36864[] = {
++	48000, 96000, 19200
++};
 +
-+	{ "OUT3 VMID", NULL, "Left Output Mixer" },
-+	{ "OUT3 VMID", NULL, "Right Output Mixer" },
++static struct snd_pcm_hw_constraint_list constraints_36864 = {
++	.count	= ARRAY_SIZE(rates_36864),
++	.list	= rates_36864,
 +};
 +
-+static int le89156_add_widgets(struct snd_soc_codec *codec)
++
++static int le89156_startup(struct snd_pcm_substream *substream,
++			  struct snd_soc_dai *dai)
 +{
-+	struct le89156_data *pdata = codec->dev->platform_data;
++	struct snd_soc_codec *codec = dai->codec;
 +	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	struct snd_soc_dapm_context *dapm = &codec->dapm;
-+	struct snd_soc_dapm_widget *w;
-+
-+	snd_soc_dapm_new_controls(dapm, le89156_dapm_widgets,
-+				  ARRAY_SIZE(le89156_dapm_widgets));
-+
-+	snd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));
-+
-+	/* In capless mode OUT3 is used to provide VMID for the
-+	 * headphone outputs, otherwise it is used as a mono mixer.
-+	 */
-+	if (pdata && pdata->capless) {
-+		snd_soc_dapm_new_controls(dapm, le89156_dapm_widgets_capless,
-+					  ARRAY_SIZE(le89156_dapm_widgets_capless));
-+
-+		snd_soc_dapm_add_routes(dapm, audio_paths_capless,
-+					ARRAY_SIZE(audio_paths_capless));
-+	} else {
-+		snd_soc_dapm_new_controls(dapm, le89156_dapm_widgets_out3,
-+					  ARRAY_SIZE(le89156_dapm_widgets_out3));
-+
-+		snd_soc_dapm_add_routes(dapm, audio_paths_out3,
-+					ARRAY_SIZE(audio_paths_out3));
-+	}
 +
-+	/* We need to power up the headphone output stage out of
-+	 * sequence for capless mode.  To save scanning the widget
-+	 * list each time to find the desired power state do so now
-+	 * and save the result.
++	/* The set of sample rates that can be supported depends on the
++	 * MCLK supplied to the CODEC - enforce this.
 +	 */
-+	list_for_each_entry(w, &codec->card->widgets, list) {
-+		if (w->dapm != &codec->dapm)
-+			continue;
-+		if (strcmp(w->name, "LOUT1 PGA") == 0)
-+			le89156->lout1 = w;
-+		if (strcmp(w->name, "ROUT1 PGA") == 0)
-+			le89156->rout1 = w;
-+		if (strcmp(w->name, "OUT3 VMID") == 0)
-+			le89156->out3 = w;
-+	}
-+
-+	return 0;
-+}
-+
-+static int le89156_set_dai_fmt(struct snd_soc_dai *codec_dai,
-+		unsigned int fmt)
-+{
-+	struct snd_soc_codec *codec = codec_dai->codec;
-+	u16 iface = 0;
-+
-+	/* set master/slave audio interface */
-+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-+	case SND_SOC_DAIFMT_CBM_CFM:
-+		iface |= 0x0040;
-+		break;
-+	case SND_SOC_DAIFMT_CBS_CFS:
-+		break;
-+	default:
++	if (!le89156->sysclk) {
++		dev_err(codec->dev,
++			"No MCLK configured, call set_sysclk() on init\n");
 +		return -EINVAL;
 +	}
 +
-+	/* interface format */
-+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-+	case SND_SOC_DAIFMT_I2S:
-+		iface |= 0x0002;
-+		break;
-+	case SND_SOC_DAIFMT_RIGHT_J:
-+		break;
-+	case SND_SOC_DAIFMT_LEFT_J:
-+		iface |= 0x0001;
-+		break;
-+	case SND_SOC_DAIFMT_DSP_A:
-+		iface |= 0x0003;
-+		break;
-+	case SND_SOC_DAIFMT_DSP_B:
-+		iface |= 0x0013;
-+		break;
-+	default:
-+		return -EINVAL;
-+	}
++	snd_pcm_hw_constraint_list(substream->runtime, 0,
++				   SNDRV_PCM_HW_PARAM_RATE,
++				   le89156->sysclk_constraints);
 +
-+	/* clock inversion */
-+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-+	case SND_SOC_DAIFMT_NB_NF:
-+		break;
-+	case SND_SOC_DAIFMT_IB_IF:
-+		iface |= 0x0090;
-+		break;
-+	case SND_SOC_DAIFMT_IB_NF:
-+		iface |= 0x0080;
-+		break;
-+	case SND_SOC_DAIFMT_NB_IF:
-+		iface |= 0x0010;
-+		break;
-+	default:
-+		return -EINVAL;
-+	}
-+
-+	/* set iface */
-+	snd_soc_write(codec, LE89156_IFACE1, iface);
 +	return 0;
 +}
 +
-+static struct {
-+	int rate;
-+	unsigned int val;
-+} alc_rates[] = {
-+	{ 48000, 0 },
-+	{ 44100, 0 },
-+	{ 32000, 1 },
-+	{ 22050, 2 },
-+	{ 24000, 2 },
-+	{ 16000, 3 },
-+	{ 11250, 4 },
-+	{ 12000, 4 },
-+	{  8000, 5 },
-+};
-+
 +static int le89156_hw_params(struct snd_pcm_substream *substream,
 +			    struct snd_pcm_hw_params *params,
 +			    struct snd_soc_dai *dai)
 +{
 +	struct snd_soc_codec *codec = dai->codec;
 +	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	u16 iface = snd_soc_read(codec, LE89156_IFACE1) & 0xfff3;
-+	snd_pcm_format_t format = params_format(params);
++	u16 iface = snd_soc_read(codec, LE89156_FORMAT_CONTROL) & 0x1FC;
 +	int i;
 +
++	/* Find a supported LRCLK ratio */
++	for (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {
++		if (le89156->sysclk / params_rate(params) ==
++		    lrclk_ratios[i].ratio)
++			break;
++	}
++
++	/* Should never happen, should be handled by constraints */
++	if (i == ARRAY_SIZE(lrclk_ratios)) {
++		dev_err(codec->dev, "MCLK/fs ratio %d unsupported\n",
++			le89156->sysclk / params_rate(params));
++		return -EINVAL;
++	}
++
 +	/* bit size */
-+	switch (format) {
++	switch (params_format(params)) {
 +	case SNDRV_PCM_FORMAT_S16_LE:
-+	case SNDRV_PCM_FORMAT_S16_BE:
 +		break;
 +	case SNDRV_PCM_FORMAT_S20_3LE:
-+	case SNDRV_PCM_FORMAT_S20_3BE:
-+		iface |= 0x0004;
++		iface |= 0x0001;
 +		break;
 +	case SNDRV_PCM_FORMAT_S24_LE:
-+	case SNDRV_PCM_FORMAT_S24_BE:
-+		iface |= 0x0008;
++		iface |= 0x0002;
++		break;
++	case SNDRV_PCM_FORMAT_S32_LE:
++		iface |= 0x0003;
 +		break;
 +	default:
-+		dev_err(codec->dev, "unsupported format %i\n", format);
++		dev_dbg(codec->dev, "le89156_hw_params:    Unsupported bit size param = %d",
++			params_format(params));
 +		return -EINVAL;
 +	}
 +
-+	/* Update filters for the new rate */
-+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-+		le89156->playback_fs = params_rate(params);
-+		le89156_set_deemph(codec);
-+	} else {
-+		for (i = 0; i < ARRAY_SIZE(alc_rates); i++)
-+			if (alc_rates[i].rate == params_rate(params))
-+				snd_soc_update_bits(codec,
-+						    LE89156_ADDCTL3, 0x7,
-+						    alc_rates[i].val);
-+	}
-+
-+	/* set iface */
-+	snd_soc_write(codec, LE89156_IFACE1, iface);
-+	return 0;
-+}
-+
-+static int le89156_mute(struct snd_soc_dai *dai, int mute)
-+{
-+	struct snd_soc_codec *codec = dai->codec;
++	dev_dbg(codec->dev, "le89156_hw_params:    bit size param = %d",
++		params_format(params));
 +
-+	if (mute)
-+		snd_soc_update_bits(codec, LE89156_DACCTL1, 0x8, 0x8);
-+	else
-+		snd_soc_update_bits(codec, LE89156_DACCTL1, 0x8, 0);
++	snd_soc_write(codec, LE89156_FORMAT_CONTROL, iface);
 +	return 0;
 +}
 +
-+static int le89156_set_bias_level_out3(struct snd_soc_codec *codec,
-+				      enum snd_soc_bias_level level)
++static int le89156_set_dai_sysclk(struct snd_soc_dai *codec_dai,
++		int clk_id, unsigned int freq, int dir)
 +{
++	struct snd_soc_codec *codec = codec_dai->codec;
 +	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
 +
-+	switch (level) {
-+	case SND_SOC_BIAS_ON:
-+		break;
-+
-+	case SND_SOC_BIAS_PREPARE:
-+		/* Set VMID to 2x50k */
-+		snd_soc_update_bits(codec, LE89156_POWER1, 0x180, 0x80);
-+		break;
++	dev_dbg(codec->dev, "le89156_set_dai_sysclk info: freq=%dHz\n", freq);
 +
-+	case SND_SOC_BIAS_STANDBY:
-+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
-+			regcache_sync(le89156->regmap);
++	switch (freq) {
++	case 11289600:
++		le89156->sysclk_constraints = &constraints_11289;
++		le89156->sysclk = freq;
++		return 0;
 +
-+			/* Enable anti-pop features */
-+			snd_soc_write(codec, LE89156_APOP1,
-+				      LE89156_POBCTRL | LE89156_SOFT_ST |
-+				      LE89156_BUFDCOPEN | LE89156_BUFIOEN);
++	case 12288000:
++		le89156->sysclk_constraints = &constraints_12288;
++		le89156->sysclk = freq;
++		return 0;
 +
-+			/* Enable & ramp VMID at 2x50k */
-+			snd_soc_update_bits(codec, LE89156_POWER1, 0x80, 0x80);
-+			msleep(100);
++	case 16384000:
++		le89156->sysclk_constraints = &constraints_16384;
++		le89156->sysclk = freq;
++		return 0;
 +
-+			/* Enable VREF */
-+			snd_soc_update_bits(codec, LE89156_POWER1, LE89156_VREF,
-+					    LE89156_VREF);
++	case 16934400:
++		le89156->sysclk_constraints = &constraints_16934;
++		le89156->sysclk = freq;
++		return 0;
 +
-+			/* Disable anti-pop features */
-+			snd_soc_write(codec, LE89156_APOP1, LE89156_BUFIOEN);
-+		}
++	case 18432000:
++		le89156->sysclk_constraints = &constraints_18432;
++		le89156->sysclk = freq;
++		return 0;
 +
-+		/* Set VMID to 2x250k */
-+		snd_soc_update_bits(codec, LE89156_POWER1, 0x180, 0x100);
-+		break;
++	case 22579200:
++	case 33868800:
++		le89156->sysclk_constraints = &constraints_22579;
++		le89156->sysclk = freq;
++		return 0;
 +
-+	case SND_SOC_BIAS_OFF:
-+		/* Enable anti-pop features */
-+		snd_soc_write(codec, LE89156_APOP1,
-+			     LE89156_POBCTRL | LE89156_SOFT_ST |
-+			     LE89156_BUFDCOPEN | LE89156_BUFIOEN);
++	case 24576000:
++		le89156->sysclk_constraints = &constraints_24576;
++		le89156->sysclk = freq;
++		return 0;
 +
-+		/* Disable VMID and VREF, let them discharge */
-+		snd_soc_write(codec, LE89156_POWER1, 0);
-+		msleep(600);
-+		break;
++	case 36864000:
++		le89156->sysclk_constraints = &constraints_36864;
++		le89156->sysclk = freq;
++		return 0;
 +	}
-+
-+	codec->dapm.bias_level = level;
-+
-+	return 0;
++	return -EINVAL;
 +}
 +
-+static int le89156_set_bias_level_capless(struct snd_soc_codec *codec,
-+					 enum snd_soc_bias_level level)
++static int le89156_set_dai_fmt(struct snd_soc_dai *codec_dai,
++		unsigned int fmt)
 +{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	int reg;
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u16 iface = snd_soc_read(codec, LE89156_FORMAT_CONTROL) & 0x1C3;
 +
-+	switch (level) {
-+	case SND_SOC_BIAS_ON:
++	/* check master/slave audio interface */
++	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
++	case SND_SOC_DAIFMT_CBS_CFS:
 +		break;
++	default:
++		return -EINVAL;
++	}
 +
-+	case SND_SOC_BIAS_PREPARE:
-+		switch (codec->dapm.bias_level) {
-+		case SND_SOC_BIAS_STANDBY:
-+			/* Enable anti pop mode */
-+			snd_soc_update_bits(codec, LE89156_APOP1,
-+					    LE89156_POBCTRL | LE89156_SOFT_ST |
-+					    LE89156_BUFDCOPEN,
-+					    LE89156_POBCTRL | LE89156_SOFT_ST |
-+					    LE89156_BUFDCOPEN);
-+
-+			/* Enable LOUT1, ROUT1 and OUT3 if they're enabled */
-+			reg = 0;
-+			if (le89156->lout1 && le89156->lout1->power)
-+				reg |= LE89156_PWR2_LOUT1;
-+			if (le89156->rout1 && le89156->rout1->power)
-+				reg |= LE89156_PWR2_ROUT1;
-+			if (le89156->out3 && le89156->out3->power)
-+				reg |= LE89156_PWR2_OUT3;
-+			snd_soc_update_bits(codec, LE89156_POWER2,
-+					    LE89156_PWR2_LOUT1 |
-+					    LE89156_PWR2_ROUT1 |
-+					    LE89156_PWR2_OUT3, reg);
-+
-+			/* Enable VMID at 2*50k */
-+			snd_soc_update_bits(codec, LE89156_POWER1,
-+					    LE89156_VMID_MASK, 0x80);
-+
-+			/* Ramp */
-+			msleep(100);
-+
-+			/* Enable VREF */
-+			snd_soc_update_bits(codec, LE89156_POWER1,
-+					    LE89156_VREF, LE89156_VREF);
-+
-+			msleep(100);
-+			break;
-+
-+		case SND_SOC_BIAS_ON:
-+			/* Enable anti-pop mode */
-+			snd_soc_update_bits(codec, LE89156_APOP1,
-+					    LE89156_POBCTRL | LE89156_SOFT_ST |
-+					    LE89156_BUFDCOPEN,
-+					    LE89156_POBCTRL | LE89156_SOFT_ST |
-+					    LE89156_BUFDCOPEN);
-+
-+			/* Disable VMID and VREF */
-+			snd_soc_update_bits(codec, LE89156_POWER1,
-+					    LE89156_VREF | LE89156_VMID_MASK, 0);
-+			break;
-+
-+		case SND_SOC_BIAS_OFF:
-+			regcache_sync(le89156->regmap);
-+			break;
-+		default:
-+			break;
-+		}
++	/* interface format */
++	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
++	case SND_SOC_DAIFMT_I2S:
++		iface |= 0x0008;
 +		break;
-+
-+	case SND_SOC_BIAS_STANDBY:
-+		switch (codec->dapm.bias_level) {
-+		case SND_SOC_BIAS_PREPARE:
-+			/* Disable HP discharge */
-+			snd_soc_update_bits(codec, LE89156_APOP2,
-+					    LE89156_DISOP | LE89156_DRES_MASK,
-+					    0);
-+
-+			/* Disable anti-pop features */
-+			snd_soc_update_bits(codec, LE89156_APOP1,
-+					    LE89156_POBCTRL | LE89156_SOFT_ST |
-+					    LE89156_BUFDCOPEN,
-+					    LE89156_POBCTRL | LE89156_SOFT_ST |
-+					    LE89156_BUFDCOPEN);
-+			break;
-+
-+		default:
-+			break;
-+		}
++	case SND_SOC_DAIFMT_RIGHT_J:
 +		break;
-+
-+	case SND_SOC_BIAS_OFF:
++	case SND_SOC_DAIFMT_LEFT_J:
++		iface |= 0x0004;
 +		break;
-+	}
-+
-+	codec->dapm.bias_level = level;
-+
-+	return 0;
-+}
-+
-+/* PLL divisors */
-+struct _pll_div {
-+	u32 pre_div:1;
-+	u32 n:4;
-+	u32 k:24;
-+};
-+
-+/* The size in bits of the pll divide multiplied by 10
-+ * to allow rounding later */
-+#define FIXED_PLL_SIZE ((1 << 24) * 10)
-+
-+static int pll_factors(unsigned int source, unsigned int target,
-+		       struct _pll_div *pll_div)
-+{
-+	unsigned long long Kpart;
-+	unsigned int K, Ndiv, Nmod;
-+
-+	pr_debug("LE89156 PLL: setting %dHz->%dHz\n", source, target);
-+
-+	/* Scale up target to PLL operating frequency */
-+	target *= 4;
-+
-+	Ndiv = target / source;
-+	if (Ndiv < 6) {
-+		source >>= 1;
-+		pll_div->pre_div = 1;
-+		Ndiv = target / source;
-+	} else
-+		pll_div->pre_div = 0;
-+
-+	if ((Ndiv < 6) || (Ndiv > 12)) {
-+		pr_err("LE89156 PLL: Unsupported N=%d\n", Ndiv);
++	case SND_SOC_DAIFMT_DSP_A:
++		iface |= 0x000C;
++		break;
++	case SND_SOC_DAIFMT_DSP_B:
++		iface |= 0x001C;
++		break;
++	default:
 +		return -EINVAL;
 +	}
 +
-+	pll_div->n = Ndiv;
-+	Nmod = target % source;
-+	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
-+
-+	do_div(Kpart, source);
-+
-+	K = Kpart & 0xFFFFFFFF;
-+
-+	/* Check if we need to round */
-+	if ((K % 10) >= 5)
-+		K += 5;
-+
-+	/* Move down to proper range now rounding is done */
-+	K /= 10;
-+
-+	pll_div->k = K;
-+
-+	pr_debug("LE89156 PLL: N=%x K=%x pre_div=%d\n",
-+		 pll_div->n, pll_div->k, pll_div->pre_div);
-+
-+	return 0;
-+}
-+
-+static int le89156_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
-+		int source, unsigned int freq_in, unsigned int freq_out)
-+{
-+	struct snd_soc_codec *codec = codec_dai->codec;
-+	u16 reg;
-+	static struct _pll_div pll_div;
-+	int ret;
-+
-+	if (freq_in && freq_out) {
-+		ret = pll_factors(freq_in, freq_out, &pll_div);
-+		if (ret != 0)
-+			return ret;
-+	}
-+
-+	/* Disable the PLL: even if we are changing the frequency the
-+	 * PLL needs to be disabled while we do so. */
-+	snd_soc_update_bits(codec, LE89156_CLOCK1, 0x1, 0);
-+	snd_soc_update_bits(codec, LE89156_POWER2, 0x1, 0);
-+
-+	if (!freq_in || !freq_out)
-+		return 0;
-+
-+	reg = snd_soc_read(codec, LE89156_PLL1) & ~0x3f;
-+	reg |= pll_div.pre_div << 4;
-+	reg |= pll_div.n;
-+
-+	if (pll_div.k) {
-+		reg |= 0x20;
-+
-+		snd_soc_write(codec, LE89156_PLL2, (pll_div.k >> 16) & 0xff);
-+		snd_soc_write(codec, LE89156_PLL3, (pll_div.k >> 8) & 0xff);
-+		snd_soc_write(codec, LE89156_PLL4, pll_div.k & 0xff);
-+	}
-+	snd_soc_write(codec, LE89156_PLL1, reg);
-+
-+	/* Turn it on */
-+	snd_soc_update_bits(codec, LE89156_POWER2, 0x1, 0x1);
-+	msleep(250);
-+	snd_soc_update_bits(codec, LE89156_CLOCK1, 0x1, 0x1);
-+
-+	return 0;
-+}
-+
-+static int le89156_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
-+		int div_id, int div)
-+{
-+	struct snd_soc_codec *codec = codec_dai->codec;
-+	u16 reg;
-+
-+	switch (div_id) {
-+	case LE89156_SYSCLKDIV:
-+		reg = snd_soc_read(codec, LE89156_CLOCK1) & 0x1f9;
-+		snd_soc_write(codec, LE89156_CLOCK1, reg | div);
-+		break;
-+	case LE89156_DACDIV:
-+		reg = snd_soc_read(codec, LE89156_CLOCK1) & 0x1c7;
-+		snd_soc_write(codec, LE89156_CLOCK1, reg | div);
++	/* clock inversion */
++	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
++	case SND_SOC_DAIFMT_NB_NF:
 +		break;
-+	case LE89156_OPCLKDIV:
-+		reg = snd_soc_read(codec, LE89156_PLL1) & 0x03f;
-+		snd_soc_write(codec, LE89156_PLL1, reg | div);
++	case SND_SOC_DAIFMT_IB_IF:
++		iface |= 0x0010;
 +		break;
-+	case LE89156_DCLKDIV:
-+		reg = snd_soc_read(codec, LE89156_CLOCK2) & 0x03f;
-+		snd_soc_write(codec, LE89156_CLOCK2, reg | div);
++	case SND_SOC_DAIFMT_IB_NF:
++		iface |= 0x0020;
 +		break;
-+	case LE89156_TOCLKSEL:
-+		reg = snd_soc_read(codec, LE89156_ADDCTL1) & 0x1fd;
-+		snd_soc_write(codec, LE89156_ADDCTL1, reg | div);
++	case SND_SOC_DAIFMT_NB_IF:
++		iface |= 0x0030;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
-+	return 0;
-+}
 +
-+static int le89156_set_bias_level(struct snd_soc_codec *codec,
-+				 enum snd_soc_bias_level level)
-+{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	dev_dbg(codec->dev, "le89156_set_dai_fmt:    Format=%x, Clock Inv=%x\n",
++				fmt & SND_SOC_DAIFMT_FORMAT_MASK,
++				((fmt & SND_SOC_DAIFMT_INV_MASK)));
 +
-+	return le89156->set_bias_level(codec, level);
++	snd_soc_write(codec, LE89156_FORMAT_CONTROL, iface);
++	return 0;
 +}
 +
-+#define LE89156_RATES SNDRV_PCM_RATE_8000_48000
++#define LE89156_RATES (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
++			SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
++			SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \
++			SNDRV_PCM_RATE_192000)
 +
-+#define LE89156_FORMATS \
-+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
-+	SNDRV_PCM_FMTBIT_S24_LE)
++#define LE89156_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
++			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 +
 +static const struct snd_soc_dai_ops le89156_dai_ops = {
-+	.hw_params = le89156_hw_params,
-+	.digital_mute = le89156_mute,
-+	.set_fmt = le89156_set_dai_fmt,
-+	.set_clkdiv = le89156_set_dai_clkdiv,
-+	.set_pll = le89156_set_dai_pll,
++	.startup	= le89156_startup,
++	.hw_params	= le89156_hw_params,
++	.set_sysclk	= le89156_set_dai_sysclk,
++	.set_fmt	= le89156_set_dai_fmt,
 +};
 +
 +static struct snd_soc_dai_driver le89156_dai = {
-+	.name = "le89156-hifi",
++	.name = "le89156",
 +	.playback = {
 +		.stream_name = "Playback",
-+		.channels_min = 1,
-+		.channels_max = 2,
-+		.rates = LE89156_RATES,
-+		.formats = LE89156_FORMATS,},
-+	.capture = {
-+		.stream_name = "Capture",
-+		.channels_min = 1,
++		.channels_min = 2,  /* Mono modes not yet supported */
 +		.channels_max = 2,
 +		.rates = LE89156_RATES,
-+		.formats = LE89156_FORMATS,},
++		.formats = LE89156_FORMATS,
++	},
 +	.ops = &le89156_dai_ops,
-+	.symmetric_rates = 1,
 +};
 +
-+static int le89156_suspend(struct snd_soc_codec *codec)
-+{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+
-+	le89156->set_bias_level(codec, SND_SOC_BIAS_OFF);
-+	return 0;
-+}
-+
++#ifdef CONFIG_PM
 +static int le89156_resume(struct snd_soc_codec *codec)
 +{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+
-+	le89156->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
++	snd_soc_cache_sync(codec);
 +	return 0;
 +}
++#else
++#define le89156_suspend NULL
++#define le89156_resume NULL
++#endif
 +
 +static int le89156_probe(struct snd_soc_codec *codec)
 +{
 +	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	struct le89156_data *pdata = dev_get_platdata(codec->dev);
-+	int ret;
-+
-+	le89156->set_bias_level = le89156_set_bias_level_out3;
++	int ret = 0;
 +
-+	if (!pdata) {
-+		dev_warn(codec->dev, "No platform data supplied\n");
-+	} else {
-+		if (pdata->capless)
-+			le89156->set_bias_level = le89156_set_bias_level_capless;
++	ret = regulator_bulk_enable(ARRAY_SIZE(le89156->supplies),
++				    le89156->supplies);
++	if (ret != 0) {
++		dev_err(codec->dev, "Failed to enable supplies: %d\n", ret);
++		goto err_get;
 +	}
 +
 +	ret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);
-+	if (ret < 0) {
++	if (ret != 0) {
 +		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-+		return ret;
++		goto err_enable;
 +	}
 +
 +	ret = le89156_reset(codec);
 +	if (ret < 0) {
 +		dev_err(codec->dev, "Failed to issue reset\n");
-+		return ret;
++		goto err_enable;
 +	}
 +
-+	le89156->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-+
-+	/* Latch the update bits */
-+	snd_soc_update_bits(codec, LE89156_LINVOL, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_RINVOL, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_LADC, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_RADC, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_LDAC, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_RDAC, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_LOUT1, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_ROUT1, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_LOUT2, 0x100, 0x100);
-+	snd_soc_update_bits(codec, LE89156_ROUT2, 0x100, 0x100);
-+
-+	snd_soc_add_codec_controls(codec, le89156_snd_controls,
-+				     ARRAY_SIZE(le89156_snd_controls));
-+	le89156_add_widgets(codec);
++	/* Change some default settings - latch VU */
++	snd_soc_update_bits(codec, LE89156_DACLLSB_ATTENUATION,
++			    LE89156_UPDATELL, LE89156_UPDATELL);
++	snd_soc_update_bits(codec, LE89156_DACLMSB_ATTENUATION,
++			    LE89156_UPDATELM, LE89156_UPDATELM);
++	snd_soc_update_bits(codec, LE89156_DACRLSB_ATTENUATION,
++			    LE89156_UPDATERL, LE89156_UPDATERL);
++	snd_soc_update_bits(codec, LE89156_DACRMSB_ATTENUATION,
++			    LE89156_UPDATERM, LE89156_UPDATERM);
++
++	dev_dbg(codec->dev, "Successful registration\n");
++	return ret;
 +
-+	return 0;
++err_enable:
++	regulator_bulk_disable(ARRAY_SIZE(le89156->supplies), le89156->supplies);
++err_get:
++	return ret;
 +}
 +
-+/* power down chip */
 +static int le89156_remove(struct snd_soc_codec *codec)
 +{
 +	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
 +
-+	le89156->set_bias_level(codec, SND_SOC_BIAS_OFF);
++	regulator_bulk_disable(ARRAY_SIZE(le89156->supplies), le89156->supplies);
++
 +	return 0;
 +}
 +
 +static struct snd_soc_codec_driver soc_codec_dev_le89156 = {
 +	.probe =	le89156_probe,
 +	.remove =	le89156_remove,
-+	.suspend =	le89156_suspend,
 +	.resume =	le89156_resume,
-+	.set_bias_level = le89156_set_bias_level,
++
++	.controls = le89156_snd_controls,
++	.num_controls = ARRAY_SIZE(le89156_snd_controls),
++	.dapm_widgets = le89156_dapm_widgets,
++	.num_dapm_widgets = ARRAY_SIZE(le89156_dapm_widgets),
++	.dapm_routes = le89156_dapm_routes,
++	.num_dapm_routes = ARRAY_SIZE(le89156_dapm_routes),
 +};
 +
++static const struct of_device_id le89156_of_match[] = {
++	{ .compatible = "zarlink,le89156", },
++	{ }
++};
++MODULE_DEVICE_TABLE(of, le89156_of_match);
++
 +static const struct regmap_config le89156_regmap = {
 +	.reg_bits = 7,
 +	.val_bits = 9,
-+	.max_register = LE89156_PLL4,
++	.max_register = LE89156_MAX_REGISTER,
 +
 +	.reg_defaults = le89156_reg_defaults,
 +	.num_reg_defaults = ARRAY_SIZE(le89156_reg_defaults),
 +	.cache_type = REGCACHE_RBTREE,
 +
-+	.volatile_reg = le89156_volatile,
++	.readable_reg = le89156_readable,
 +};
 +
-+static int le89156_i2c_probe(struct i2c_client *i2c,
-+			    const struct i2c_device_id *id)
++static int le89156_spi_probe(struct spi_device *spi)
 +{
-+	struct le89156_data *pdata = dev_get_platdata(&i2c->dev);
 +	struct le89156_priv *le89156;
-+	int ret;
++	int ret, i;
 +
-+	le89156 = devm_kzalloc(&i2c->dev, sizeof(struct le89156_priv),
-+			      GFP_KERNEL);
++	le89156 = devm_kzalloc(&spi->dev, sizeof(struct le89156_priv),
++			     GFP_KERNEL);
 +	if (le89156 == NULL)
 +		return -ENOMEM;
 +
-+	le89156->regmap = devm_regmap_init_i2c(i2c, &le89156_regmap);
-+	if (IS_ERR(le89156->regmap))
-+		return PTR_ERR(le89156->regmap);
-+
-+	if (pdata && pdata->shared_lrclk) {
-+		ret = regmap_update_bits(le89156->regmap, LE89156_ADDCTL2,
-+					 0x4, 0x4);
-+		if (ret != 0) {
-+			dev_err(&i2c->dev, "Failed to enable LRCM: %d\n",
-+				ret);
-+			return ret;
-+		}
++	for (i = 0; i < ARRAY_SIZE(le89156->supplies); i++)
++		le89156->supplies[i].supply = le89156_supply_names[i];
++
++	ret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(le89156->supplies),
++				      le89156->supplies);
++	if (ret != 0) {
++		dev_err(&spi->dev, "Failed to request supplies: %d\n", ret);
++		return ret;
++	}
++
++	le89156->regmap = devm_regmap_init_spi(spi, &le89156_regmap);
++	if (IS_ERR(le89156->regmap)) {
++		ret = PTR_ERR(le89156->regmap);
++		dev_err(&spi->dev, "Failed to init regmap: %d\n", ret);
++		return ret;
 +	}
 +
-+	i2c_set_clientdata(i2c, le89156);
++	spi_set_drvdata(spi, le89156);
 +
-+	ret = snd_soc_register_codec(&i2c->dev,
++	ret = snd_soc_register_codec(&spi->dev,
 +			&soc_codec_dev_le89156, &le89156_dai, 1);
-+
 +	return ret;
 +}
 +
-+static int le89156_i2c_remove(struct i2c_client *client)
++static int le89156_spi_remove(struct spi_device *spi)
 +{
-+	snd_soc_unregister_codec(&client->dev);
++	snd_soc_unregister_codec(&spi->dev);
 +	return 0;
 +}
 +
-+static const struct i2c_device_id le89156_i2c_id[] = {
-+	{ "le89156", 0 },
-+	{ }
-+};
-+MODULE_DEVICE_TABLE(i2c, le89156_i2c_id);
-+
-+static struct i2c_driver le89156_i2c_driver = {
++static struct spi_driver le89156_spi_driver = {
 +	.driver = {
-+		.name = "le89156",
-+		.owner = THIS_MODULE,
++		.name	= "le89156",
++		.owner	= THIS_MODULE,
++		.of_match_table = le89156_of_match,
 +	},
-+	.probe =    le89156_i2c_probe,
-+	.remove =   le89156_i2c_remove,
-+	.id_table = le89156_i2c_id,
++	.probe		= le89156_spi_probe,
++	.remove		= le89156_spi_remove,
 +};
 +
-+module_i2c_driver(le89156_i2c_driver);
++static int __init le89156_modinit(void)
++{
++	int ret = 0;
++
++	ret = spi_register_driver(&le89156_spi_driver);
++	if (ret != 0) {
++		printk(KERN_ERR "Failed to register le89156 SPI driver: %d\n",
++		       ret);
++	}
++
++	return ret;
++}
++module_init(le89156_modinit);
++
++static void __exit le89156_exit(void)
++{
++	spi_unregister_driver(&le89156_spi_driver);
++}
++module_exit(le89156_exit);
 +
 +MODULE_DESCRIPTION("ASoC LE89156 driver");
-+MODULE_AUTHOR("Liam Girdwood");
++MODULE_AUTHOR("Ian Lartey <ian@opensource.wolfsonmicro.com>");
 +MODULE_LICENSE("GPL");
 --- /dev/null
 +++ b/sound/soc/codecs/le89156.h
-@@ -0,0 +1,113 @@
+@@ -0,0 +1,211 @@
 +/*
-+ * le89156.h  --  LE89156 Soc Audio driver
++ * le89156.h  --  WM8423 ASoC driver
++ *
++ * Copyright 2010 Wolfson Microelectronics, plc
++ *
++ * Author: Ian Lartey <ian@opensource.wolfsonmicro.com>
++ *
++ * Based on wm8753.h
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
@@ -1116,106 +595,198 @@
 +#ifndef _LE89156_H
 +#define _LE89156_H
 +
-+/* LE89156 register space */
-+
-+
-+#define LE89156_CACHEREGNUM 	56
-+
-+#define LE89156_LINVOL		0x0
-+#define LE89156_RINVOL		0x1
-+#define LE89156_LOUT1		0x2
-+#define LE89156_ROUT1		0x3
-+#define LE89156_CLOCK1		0x4
-+#define LE89156_DACCTL1		0x5
-+#define LE89156_DACCTL2		0x6
-+#define LE89156_IFACE1		0x7
-+#define LE89156_CLOCK2		0x8
-+#define LE89156_IFACE2		0x9
-+#define LE89156_LDAC		0xa
-+#define LE89156_RDAC		0xb
-+
-+#define LE89156_RESET		0xf
-+#define LE89156_3D		0x10
-+#define LE89156_ALC1		0x11
-+#define LE89156_ALC2		0x12
-+#define LE89156_ALC3		0x13
-+#define LE89156_NOISEG		0x14
-+#define LE89156_LADC		0x15
-+#define LE89156_RADC		0x16
-+#define LE89156_ADDCTL1		0x17
-+#define LE89156_ADDCTL2		0x18
-+#define LE89156_POWER1		0x19
-+#define LE89156_POWER2		0x1a
-+#define LE89156_ADDCTL3		0x1b
-+#define LE89156_APOP1		0x1c
-+#define LE89156_APOP2		0x1d
-+
-+#define LE89156_LINPATH		0x20
-+#define LE89156_RINPATH		0x21
-+#define LE89156_LOUTMIX		0x22
-+
-+#define LE89156_ROUTMIX		0x25
-+#define LE89156_MONOMIX1		0x26
-+#define LE89156_MONOMIX2		0x27
-+#define LE89156_LOUT2		0x28
-+#define LE89156_ROUT2		0x29
-+#define LE89156_MONO		0x2a
-+#define LE89156_INBMIX1		0x2b
-+#define LE89156_INBMIX2		0x2c
-+#define LE89156_BYPASS1		0x2d
-+#define LE89156_BYPASS2		0x2e
-+#define LE89156_POWER3		0x2f
-+#define LE89156_ADDCTL4		0x30
-+#define LE89156_CLASSD1		0x31
-+
-+#define LE89156_CLASSD3		0x33
-+#define LE89156_PLL1		0x34
-+#define LE89156_PLL2		0x35
-+#define LE89156_PLL3		0x36
-+#define LE89156_PLL4		0x37
++/*
++ * Register values.
++ */
++#define LE89156_DACLLSB_ATTENUATION              0x00
++#define LE89156_DACLMSB_ATTENUATION              0x01
++#define LE89156_DACRLSB_ATTENUATION              0x02
++#define LE89156_DACRMSB_ATTENUATION              0x03
++#define LE89156_VOLUME_CONTROL                   0x04
++#define LE89156_FORMAT_CONTROL                   0x05
++#define LE89156_FILTER_CONTROL                   0x06
++#define LE89156_MODE_CONTROL_1                   0x07
++#define LE89156_MODE_CONTROL_2                   0x08
++#define LE89156_RESET                            0x09
++#define LE89156_ADDITIONAL_CONTROL_1             0x20
++
++#define LE89156_REGISTER_COUNT                   11
++#define LE89156_MAX_REGISTER                     0x20
 +
++/*
++ * Field Definitions.
++ */
 +
 +/*
-+ * LE89156 Clock dividers
++ * R0 (0x00) - DACLLSB_ATTENUATION
 + */
-+#define LE89156_SYSCLKDIV 		0
-+#define LE89156_DACDIV			1
-+#define LE89156_OPCLKDIV			2
-+#define LE89156_DCLKDIV			3
-+#define LE89156_TOCLKSEL			4
-+
-+#define LE89156_SYSCLK_DIV_1		(0 << 1)
-+#define LE89156_SYSCLK_DIV_2		(2 << 1)
-+
-+#define LE89156_SYSCLK_MCLK		(0 << 0)
-+#define LE89156_SYSCLK_PLL		(1 << 0)
-+
-+#define LE89156_DAC_DIV_1		(0 << 3)
-+#define LE89156_DAC_DIV_1_5		(1 << 3)
-+#define LE89156_DAC_DIV_2		(2 << 3)
-+#define LE89156_DAC_DIV_3		(3 << 3)
-+#define LE89156_DAC_DIV_4		(4 << 3)
-+#define LE89156_DAC_DIV_5_5		(5 << 3)
-+#define LE89156_DAC_DIV_6		(6 << 3)
-+
-+#define LE89156_DCLK_DIV_1_5		(0 << 6)
-+#define LE89156_DCLK_DIV_2		(1 << 6)
-+#define LE89156_DCLK_DIV_3		(2 << 6)
-+#define LE89156_DCLK_DIV_4		(3 << 6)
-+#define LE89156_DCLK_DIV_6		(4 << 6)
-+#define LE89156_DCLK_DIV_8		(5 << 6)
-+#define LE89156_DCLK_DIV_12		(6 << 6)
-+#define LE89156_DCLK_DIV_16		(7 << 6)
-+
-+#define LE89156_TOCLK_F19		(0 << 1)
-+#define LE89156_TOCLK_F21		(1 << 1)
-+
-+#define LE89156_OPCLK_DIV_1		(0 << 0)
-+#define LE89156_OPCLK_DIV_2		(1 << 0)
-+#define LE89156_OPCLK_DIV_3		(2 << 0)
-+#define LE89156_OPCLK_DIV_4		(3 << 0)
-+#define LE89156_OPCLK_DIV_5_5		(4 << 0)
-+#define LE89156_OPCLK_DIV_6		(5 << 0)
++#define LE89156_UPDATELL                         0x0020  /* UPDATELL */
++#define LE89156_UPDATELL_MASK                    0x0020  /* UPDATELL */
++#define LE89156_UPDATELL_SHIFT                        5  /* UPDATELL */
++#define LE89156_UPDATELL_WIDTH                        1  /* UPDATELL */
++#define LE89156_LAT_4_0_MASK                     0x001F  /* LAT[4:0] - [4:0] */
++#define LE89156_LAT_4_0_SHIFT                         0  /* LAT[4:0] - [4:0] */
++#define LE89156_LAT_4_0_WIDTH                         5  /* LAT[4:0] - [4:0] */
++
++/*
++ * R1 (0x01) - DACLMSB_ATTENUATION
++ */
++#define LE89156_UPDATELM                         0x0020  /* UPDATELM */
++#define LE89156_UPDATELM_MASK                    0x0020  /* UPDATELM */
++#define LE89156_UPDATELM_SHIFT                        5  /* UPDATELM */
++#define LE89156_UPDATELM_WIDTH                        1  /* UPDATELM */
++#define LE89156_LAT_9_5_0_MASK                   0x001F  /* LAT[9:5] - [4:0] */
++#define LE89156_LAT_9_5_0_SHIFT                       0  /* LAT[9:5] - [4:0] */
++#define LE89156_LAT_9_5_0_WIDTH                       5  /* LAT[9:5] - [4:0] */
++
++/*
++ * R2 (0x02) - DACRLSB_ATTENUATION
++ */
++#define LE89156_UPDATERL                         0x0020  /* UPDATERL */
++#define LE89156_UPDATERL_MASK                    0x0020  /* UPDATERL */
++#define LE89156_UPDATERL_SHIFT                        5  /* UPDATERL */
++#define LE89156_UPDATERL_WIDTH                        1  /* UPDATERL */
++#define LE89156_RAT_4_0_MASK                     0x001F  /* RAT[4:0] - [4:0] */
++#define LE89156_RAT_4_0_SHIFT                         0  /* RAT[4:0] - [4:0] */
++#define LE89156_RAT_4_0_WIDTH                         5  /* RAT[4:0] - [4:0] */
++
++/*
++ * R3 (0x03) - DACRMSB_ATTENUATION
++ */
++#define LE89156_UPDATERM                         0x0020  /* UPDATERM */
++#define LE89156_UPDATERM_MASK                    0x0020  /* UPDATERM */
++#define LE89156_UPDATERM_SHIFT                        5  /* UPDATERM */
++#define LE89156_UPDATERM_WIDTH                        1  /* UPDATERM */
++#define LE89156_RAT_9_5_0_MASK                   0x001F  /* RAT[9:5] - [4:0] */
++#define LE89156_RAT_9_5_0_SHIFT                       0  /* RAT[9:5] - [4:0] */
++#define LE89156_RAT_9_5_0_WIDTH                       5  /* RAT[9:5] - [4:0] */
++
++/*
++ * R4 (0x04) - VOLUME_CONTROL
++ */
++#define LE89156_AMUTE                            0x0080  /* AMUTE */
++#define LE89156_AMUTE_MASK                       0x0080  /* AMUTE */
++#define LE89156_AMUTE_SHIFT                           7  /* AMUTE */
++#define LE89156_AMUTE_WIDTH                           1  /* AMUTE */
++#define LE89156_ZFLAG_MASK                       0x0060  /* ZFLAG - [6:5] */
++#define LE89156_ZFLAG_SHIFT                           5  /* ZFLAG - [6:5] */
++#define LE89156_ZFLAG_WIDTH                           2  /* ZFLAG - [6:5] */
++#define LE89156_IZD                              0x0010  /* IZD */
++#define LE89156_IZD_MASK                         0x0010  /* IZD */
++#define LE89156_IZD_SHIFT                             4  /* IZD */
++#define LE89156_IZD_WIDTH                             1  /* IZD */
++#define LE89156_SOFT                             0x0008  /* SOFT MUTE */
++#define LE89156_SOFT_MASK                        0x0008  /* SOFT MUTE */
++#define LE89156_SOFT_SHIFT                            3  /* SOFT MUTE */
++#define LE89156_SOFT_WIDTH                            1  /* SOFT MUTE */
++#define LE89156_ATC                              0x0004  /* ATC */
++#define LE89156_ATC_MASK                         0x0004  /* ATC */
++#define LE89156_ATC_SHIFT                             2  /* ATC */
++#define LE89156_ATC_WIDTH                             1  /* ATC */
++#define LE89156_ATT2DB                           0x0002  /* ATT2DB */
++#define LE89156_ATT2DB_MASK                      0x0002  /* ATT2DB */
++#define LE89156_ATT2DB_SHIFT                          1  /* ATT2DB */
++#define LE89156_ATT2DB_WIDTH                          1  /* ATT2DB */
++#define LE89156_VOL_RAMP                         0x0001  /* VOL_RAMP */
++#define LE89156_VOL_RAMP_MASK                    0x0001  /* VOL_RAMP */
++#define LE89156_VOL_RAMP_SHIFT                        0  /* VOL_RAMP */
++#define LE89156_VOL_RAMP_WIDTH                        1  /* VOL_RAMP */
++
++/*
++ * R5 (0x05) - FORMAT_CONTROL
++ */
++#define LE89156_PWDN                             0x0080  /* PWDN */
++#define LE89156_PWDN_MASK                        0x0080  /* PWDN */
++#define LE89156_PWDN_SHIFT                            7  /* PWDN */
++#define LE89156_PWDN_WIDTH                            1  /* PWDN */
++#define LE89156_REV                              0x0040  /* REV */
++#define LE89156_REV_MASK                         0x0040  /* REV */
++#define LE89156_REV_SHIFT                             6  /* REV */
++#define LE89156_REV_WIDTH                             1  /* REV */
++#define LE89156_BCP                              0x0020  /* BCP */
++#define LE89156_BCP_MASK                         0x0020  /* BCP */
++#define LE89156_BCP_SHIFT                             5  /* BCP */
++#define LE89156_BCP_WIDTH                             1  /* BCP */
++#define LE89156_LRP                              0x0010  /* LRP */
++#define LE89156_LRP_MASK                         0x0010  /* LRP */
++#define LE89156_LRP_SHIFT                             4  /* LRP */
++#define LE89156_LRP_WIDTH                             1  /* LRP */
++#define LE89156_FMT_MASK                         0x000C  /* FMT - [3:2] */
++#define LE89156_FMT_SHIFT                             2  /* FMT - [3:2] */
++#define LE89156_FMT_WIDTH                             2  /* FMT - [3:2] */
++#define LE89156_IWL_MASK                         0x0003  /* IWL - [1:0] */
++#define LE89156_IWL_SHIFT                             0  /* IWL - [1:0] */
++#define LE89156_IWL_WIDTH                             2  /* IWL - [1:0] */
++
++/*
++ * R6 (0x06) - FILTER_CONTROL
++ */
++#define LE89156_ZFLAG_HI                         0x0080  /* ZFLAG_HI */
++#define LE89156_ZFLAG_HI_MASK                    0x0080  /* ZFLAG_HI */
++#define LE89156_ZFLAG_HI_SHIFT                        7  /* ZFLAG_HI */
++#define LE89156_ZFLAG_HI_WIDTH                        1  /* ZFLAG_HI */
++#define LE89156_DEEMPH_MASK                      0x0060  /* DEEMPH - [6:5] */
++#define LE89156_DEEMPH_SHIFT                          5  /* DEEMPH - [6:5] */
++#define LE89156_DEEMPH_WIDTH                          2  /* DEEMPH - [6:5] */
++#define LE89156_DSDFILT_MASK                     0x0018  /* DSDFILT - [4:3] */
++#define LE89156_DSDFILT_SHIFT                         3  /* DSDFILT - [4:3] */
++#define LE89156_DSDFILT_WIDTH                         2  /* DSDFILT - [4:3] */
++#define LE89156_FIRSEL_MASK                      0x0007  /* FIRSEL - [2:0] */
++#define LE89156_FIRSEL_SHIFT                          0  /* FIRSEL - [2:0] */
++#define LE89156_FIRSEL_WIDTH                          3  /* FIRSEL - [2:0] */
++
++/*
++ * R7 (0x07) - MODE_CONTROL_1
++ */
++#define LE89156_MODE8X                           0x0080  /* MODE8X */
++#define LE89156_MODE8X_MASK                      0x0080  /* MODE8X */
++#define LE89156_MODE8X_SHIFT                          7  /* MODE8X */
++#define LE89156_MODE8X_WIDTH                          1  /* MODE8X */
++#define LE89156_OSR_MASK                         0x0060  /* OSR - [6:5] */
++#define LE89156_OSR_SHIFT                             5  /* OSR - [6:5] */
++#define LE89156_OSR_WIDTH                             2  /* OSR - [6:5] */
++#define LE89156_SR_MASK                          0x001C  /* SR - [4:2] */
++#define LE89156_SR_SHIFT                              2  /* SR - [4:2] */
++#define LE89156_SR_WIDTH                              3  /* SR - [4:2] */
++#define LE89156_MODESEL_MASK                     0x0003  /* MODESEL - [1:0] */
++#define LE89156_MODESEL_SHIFT                         0  /* MODESEL - [1:0] */
++#define LE89156_MODESEL_WIDTH                         2  /* MODESEL - [1:0] */
++
++/*
++ * R8 (0x08) - MODE_CONTROL_2
++ */
++#define LE89156_DSD_GAIN                         0x0040  /* DSD_GAIN */
++#define LE89156_DSD_GAIN_MASK                    0x0040  /* DSD_GAIN */
++#define LE89156_DSD_GAIN_SHIFT                        6  /* DSD_GAIN */
++#define LE89156_DSD_GAIN_WIDTH                        1  /* DSD_GAIN */
++#define LE89156_SDOUT                            0x0020  /* SDOUT */
++#define LE89156_SDOUT_MASK                       0x0020  /* SDOUT */
++#define LE89156_SDOUT_SHIFT                           5  /* SDOUT */
++#define LE89156_SDOUT_WIDTH                           1  /* SDOUT */
++#define LE89156_DOUT                             0x0010  /* DOUT */
++#define LE89156_DOUT_MASK                        0x0010  /* DOUT */
++#define LE89156_DOUT_SHIFT                            4  /* DOUT */
++#define LE89156_DOUT_WIDTH                            1  /* DOUT */
++#define LE89156_DIFF_MASK                        0x000C  /* DIFF - [3:2] */
++#define LE89156_DIFF_SHIFT                            2  /* DIFF - [3:2] */
++#define LE89156_DIFF_WIDTH                            2  /* DIFF - [3:2] */
++#define LE89156_DITHER_MASK                      0x0003  /* DITHER - [1:0] */
++#define LE89156_DITHER_SHIFT                          0  /* DITHER - [1:0] */
++#define LE89156_DITHER_WIDTH                          2  /* DITHER - [1:0] */
++
++/*
++ * R32 (0x20) - ADDITONAL_CONTROL_1
++ */
++#define LE89156_DSD_LEVEL                        0x0002  /* DSD_LEVEL */
++#define LE89156_DSD_LEVEL_MASK                   0x0002  /* DSD_LEVEL */
++#define LE89156_DSD_LEVEL_SHIFT                       1  /* DSD_LEVEL */
++#define LE89156_DSD_LEVEL_WIDTH                       1  /* DSD_LEVEL */
++#define LE89156_DSD_NO_NOTCH                     0x0001  /* DSD_NO_NOTCH */
++#define LE89156_DSD_NO_NOTCH_MASK                0x0001  /* DSD_NO_NOTCH */
++#define LE89156_DSD_NO_NOTCH_SHIFT                    0  /* DSD_NO_NOTCH */
++#define LE89156_DSD_NO_NOTCH_WIDTH                    1  /* DSD_NO_NOTCH */
++
++#define  LE89156_SYSCLK 0
 +
 +#endif
 --- a/sound/soc/ralink/Kconfig
@@ -1346,7 +917,7 @@
 +	card->dev = &pdev->dev;
 +
 +	rt5350_le89156_dai.cpu_of_node = of_parse_phandle(np, "controller", 0);
-+	rt5350_le89156_dai.codec_of_node = of_parse_phandle(np, "codec", 0);
++	rt5350_le89156_dai.codec_of_node = of_parse_phandle(np, "audio-codec", 0);
 +	rt5350_le89156_dai.platform_of_node = rt5350_le89156_dai.cpu_of_node;
 +
 +	ret = snd_soc_register_card(card);
@@ -1835,7 +1406,7 @@
 +}
 +
 +static const struct of_device_id rt5350_pcm_match[] = {
-+	{ .compatible = "ralink,rt5350a-pcm" },
++	{ .compatible = "ralink,rt5350-pcm" },
 +	{},
 +};
 +MODULE_DEVICE_TABLE(of, rt5350_pcm_match);
@@ -1894,3 +1465,17 @@
  config SND_SOC_LM49453
  	tristate
  
+--- a/drivers/spi/spi-rt2880.c
++++ b/drivers/spi/spi-rt2880.c
+@@ -25,7 +25,11 @@
+ 
+ #define DRIVER_NAME			"spi-rt2880"
+ /* only one slave is supported*/
++#ifdef CONFIG_SOC_RT305X
++#define RALINK_NUM_CHIPSELECTS		2
++#else
+ #define RALINK_NUM_CHIPSELECTS		1
++#endif
+ /* in usec */
+ #define RALINK_SPI_WAIT_MAX_LOOP	2000
+

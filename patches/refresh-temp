Bottom: 2903221850dbc369b3e1cbf3f43ee254b9ae79b2
Top:    3d52e57654b78b8e8668f1674b25be50a15c8359
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2014-01-01 16:53:50 -0500

Refresh of zarlink

---

diff --git a/target/linux/ramips/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom b/target/linux/ramips/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom
index d3e0242..24dbfe8 100644
--- a/target/linux/ramips/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom
+++ b/target/linux/ramips/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom
@@ -64,6 +64,7 @@ case "$FIRMWARE" in
 	all5003 | \
 	argus-atp52b | \
 	awm002-evb | \
+	zarlink | \
 	bc2 | \
 	br6425 | \
 	broadway | \
diff --git a/target/linux/ramips/base-files/etc/uci-defaults/02_network b/target/linux/ramips/base-files/etc/uci-defaults/02_network
index a9914fd..1eab5ba 100755
--- a/target/linux/ramips/base-files/etc/uci-defaults/02_network
+++ b/target/linux/ramips/base-files/etc/uci-defaults/02_network
@@ -42,6 +42,7 @@ ramips_setup_interfaces()
 	all5002 | \
 	all5003 | \
 	awm002-evb | \
+	zarlink | \
 	broadway | \
 	dcs-930| \
 	wnce2001)
diff --git a/target/linux/ramips/base-files/lib/preinit/06_set_iface_mac b/target/linux/ramips/base-files/lib/preinit/06_set_iface_mac
index 0c4ee13..e4f67ca 100644
--- a/target/linux/ramips/base-files/lib/preinit/06_set_iface_mac
+++ b/target/linux/ramips/base-files/lib/preinit/06_set_iface_mac
@@ -60,6 +60,7 @@ preinit_set_mac_address() {
 	all5002 |\
 	all5003 |\
 	awm002-evb |\
+	zarlink |\
 	carambola |\
 	dir-615-h1 |\
 	fonera20n |\
diff --git a/target/linux/ramips/base-files/lib/ramips.sh b/target/linux/ramips/base-files/lib/ramips.sh
index d62002e..56bfa1e 100755
--- a/target/linux/ramips/base-files/lib/ramips.sh
+++ b/target/linux/ramips/base-files/lib/ramips.sh
@@ -49,6 +49,9 @@ ramips_board_detect() {
 	*"AsiaRF AWM002 EVB")
 		name="awm002-evb"
 		;;
+	*"AsiaRF Zarlink")
+		name="zarlink"
+		;;
 	*"BR6524N")
 		name="br6524n"
 		;;
diff --git a/target/linux/ramips/base-files/lib/upgrade/platform.sh b/target/linux/ramips/base-files/lib/upgrade/platform.sh
index babeaf2..f9b1b5f 100755
--- a/target/linux/ramips/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ramips/base-files/lib/upgrade/platform.sh
@@ -25,6 +25,7 @@ platform_check_image() {
 	all5003 | \
 	asl26555 | \
 	awm002-evb | \
+	zarlink | \
 	bc2 | \
 	broadway | \
 	carambola | \
diff --git a/target/linux/ramips/dts/ZARLINK.dts b/target/linux/ramips/dts/ZARLINK.dts
index 0e56303..5de611e 100644
--- a/target/linux/ramips/dts/ZARLINK.dts
+++ b/target/linux/ramips/dts/ZARLINK.dts
@@ -4,7 +4,7 @@
 
 / {
 	compatible = "ZARLINK", "ralink,rt5350-soc";
-	model = "ReliableTV Zarlink";
+	model = "AsiaRF Zarlink";
 
 	palmbus@10000000 {
 		spi@b00 {
diff --git a/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch b/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
index ac18c7f..cab19e1 100644
--- a/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
+++ b/target/linux/ramips/patches-3.10/0320-rt5350-zarlink.patch
@@ -1,13 +1,12 @@
 --- /dev/null
 +++ b/sound/soc/codecs/le89156.c
-@@ -0,0 +1,574 @@
+@@ -0,0 +1,704 @@
 +/*
-+ * le89156.c  --  LE89156 ALSA SoC Audio driver
++ * le89156.c  --  LE89156 ALSA Soc Audio driver
 + *
-+ * Copyright 2010-1 Wolfson Microelectronics plc
-+ *
-+ * Author: Ian Lartey <ian@opensource.wolfsonmicro.com>
++ * Copyright 2006 Wolfson Microelectronics PLC.
 + *
++ * Author: Liam Girdwood <lrg@slimlogic.co.uk>
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
@@ -16,319 +15,388 @@
 +
 +#include <linux/module.h>
 +#include <linux/moduleparam.h>
++#include <linux/kernel.h>
 +#include <linux/init.h>
 +#include <linux/delay.h>
 +#include <linux/pm.h>
 +#include <linux/spi/spi.h>
-+#include <linux/regmap.h>
-+#include <linux/regulator/consumer.h>
 +#include <linux/slab.h>
 +#include <linux/of_device.h>
++#include <linux/regmap.h>
 +#include <sound/core.h>
 +#include <sound/pcm.h>
 +#include <sound/pcm_params.h>
 +#include <sound/soc.h>
 +#include <sound/initval.h>
-+#include <sound/tlv.h>
 +
 +#include "le89156.h"
 +
-+#define LE89156_NUM_SUPPLIES 2
-+static const char *le89156_supply_names[LE89156_NUM_SUPPLIES] = {
-+	"AVDD",
-+	"DVDD",
-+};
-+
-+#define LE89156_NUM_RATES 6
-+
-+/* codec private data */
-+struct le89156_priv {
-+	struct regmap *regmap;
-+	struct regulator_bulk_data supplies[LE89156_NUM_SUPPLIES];
-+	unsigned int sysclk;
-+	struct snd_pcm_hw_constraint_list *sysclk_constraints;
-+};
-+
++/*
++ * le89156 register cache
++ * We can't read the LE89156 register space when we are
++ * using 2 wire for device control, so we cache them instead.
++ */
 +static const struct reg_default le89156_reg_defaults[] = {
-+	{  0, 0x0000 },     /* R0  - DACLLSB Attenuation */
-+	{  1, 0x0000 },     /* R1  - DACLMSB Attenuation */
-+	{  2, 0x0000 },     /* R2  - DACRLSB Attenuation */
-+	{  3, 0x0000 },     /* R3  - DACRMSB Attenuation */
-+	{  4, 0x0000 },     /* R4  - Volume Control */
-+	{  5, 0x000A },     /* R5  - Format Control */
-+	{  6, 0x0000 },     /* R6  - Filter Control */
-+	{  7, 0x0000 },     /* R7  - Mode Control 1 */
-+	{  8, 0x0002 },     /* R8  - Mode Control 2 */
-+	{ 32, 0x0002 },     /* R32 - ADDITONAL_CONTROL_1 */
++	{  1, 0x0000 },
++	{  2, 0x0000 },
++	{  3, 0x0000 },
++	{  4, 0x0050 },
++	{  5, 0x0000 },
++	{  6, 0x0140 },
++	{  7, 0x0000 },
++	{  8, 0x0000 },
++	{  9, 0x0000 },
++	{ 10, 0x0000 },
++	{ 11, 0x00ff },
++	{ 12, 0x0000 },
++	{ 13, 0x0000 },
++	{ 14, 0x0100 },
++	{ 15, 0x00ff },
++	{ 16, 0x0000 },
++	{ 17, 0x0000 },
++	{ 18, 0x012c },
++	{ 19, 0x002c },
++	{ 20, 0x002c },
++	{ 21, 0x002c },
++	{ 22, 0x002c },
++	{ 23, 0x0000 },
++	{ 24, 0x0032 },
++	{ 25, 0x0000 },
++	{ 26, 0x0000 },
++	{ 27, 0x0000 },
++	{ 28, 0x0000 },
++	{ 29, 0x0000 },
++	{ 30, 0x0000 },
++	{ 31, 0x0000 },
++	{ 32, 0x0038 },
++	{ 33, 0x000b },
++	{ 34, 0x0032 },
++	{ 35, 0x0000 },
++	{ 36, 0x0008 },
++	{ 37, 0x000c },
++	{ 38, 0x0093 },
++	{ 39, 0x00e9 },
++	{ 40, 0x0000 },
++	{ 41, 0x0000 },
++	{ 42, 0x0000 },
++	{ 43, 0x0000 },
++	{ 44, 0x0003 },
++	{ 45, 0x0010 },
++	{ 46, 0x0000 },
++	{ 47, 0x0000 },
++	{ 48, 0x0000 },
++	{ 49, 0x0002 },
++	{ 50, 0x0001 },
++	{ 51, 0x0000 },
++	{ 52, 0x0000 },
++	{ 53, 0x0000 },
++	{ 54, 0x0039 },
++	{ 55, 0x0000 },
++	{ 56, 0x0001 },
 +};
 +
-+static bool le89156_readable(struct device *dev, unsigned int reg)
++static bool le89156_volatile(struct device *dev, unsigned int reg)
 +{
 +	switch (reg) {
-+	case LE89156_DACLLSB_ATTENUATION:
-+	case LE89156_DACLMSB_ATTENUATION:
-+	case LE89156_DACRLSB_ATTENUATION:
-+	case LE89156_DACRMSB_ATTENUATION:
-+	case LE89156_VOLUME_CONTROL:
-+	case LE89156_FORMAT_CONTROL:
-+	case LE89156_FILTER_CONTROL:
-+	case LE89156_MODE_CONTROL_1:
-+	case LE89156_MODE_CONTROL_2:
-+	case LE89156_ADDITIONAL_CONTROL_1:
++	case LE89156_RESET:
 +		return true;
 +	default:
 +		return false;
 +	}
 +}
 +
-+static int le89156_reset(struct snd_soc_codec *codec)
-+{
-+	return snd_soc_write(codec, LE89156_RESET, 0);
-+}
++#define LE89156_POWER1_BIASEN  0x08
++#define LE89156_POWER1_BUFIOEN 0x10
 +
-+static const DECLARE_TLV_DB_SCALE(dac_tlv_fine, -12700, 13, 0);
-+static const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 400, 0);
++#define le89156_reset(c)	snd_soc_write(c, LE89156_RESET, 0)
 +
-+static const struct snd_kcontrol_new le89156_snd_controls[] = {
-+SOC_DOUBLE_R_TLV("Fine Playback Volume", LE89156_DACLLSB_ATTENUATION,
-+		 LE89156_DACRLSB_ATTENUATION, 1, 255, 1, dac_tlv_fine),
-+SOC_DOUBLE_R_TLV("Playback Volume", LE89156_DACLMSB_ATTENUATION,
-+		 LE89156_DACRMSB_ATTENUATION, 0, 511, 1, dac_tlv),
++/* codec private data */
++struct le89156_priv {
++	struct regmap *regmap;
 +};
 +
-+static const struct snd_soc_dapm_widget le89156_dapm_widgets[] = {
-+SND_SOC_DAPM_DAC("DACL", "Playback", SND_SOC_NOPM, 0, 0),
-+SND_SOC_DAPM_DAC("DACR", "Playback", SND_SOC_NOPM, 0, 0),
-+SND_SOC_DAPM_OUTPUT("VOUTLP"),
-+SND_SOC_DAPM_OUTPUT("VOUTLN"),
-+SND_SOC_DAPM_OUTPUT("VOUTRP"),
-+SND_SOC_DAPM_OUTPUT("VOUTRN"),
-+};
++static const char *le89156_companding[] = { "Off", "NC", "u-law", "A-law" };
++static const char *le89156_deemp[] = { "None", "32kHz", "44.1kHz", "48kHz" };
++static const char *le89156_alc[] = { "ALC", "Limiter" };
 +
-+static const struct snd_soc_dapm_route le89156_dapm_routes[] = {
-+	{ "VOUTLP", NULL, "DACL" },
-+	{ "VOUTLN", NULL, "DACL" },
-+	{ "VOUTRP", NULL, "DACR" },
-+	{ "VOUTRN", NULL, "DACR" },
++static const struct soc_enum le89156_enum[] = {
++	SOC_ENUM_SINGLE(LE89156_COMP, 1, 4, le89156_companding), /* adc */
++	SOC_ENUM_SINGLE(LE89156_COMP, 3, 4, le89156_companding), /* dac */
++	SOC_ENUM_SINGLE(LE89156_DAC,  4, 4, le89156_deemp),
++	SOC_ENUM_SINGLE(LE89156_ALC3,  8, 2, le89156_alc),
 +};
 +
-+static struct {
-+	int value;
-+	int ratio;
-+} lrclk_ratios[LE89156_NUM_RATES] = {
-+	{ 1, 128 },
-+	{ 2, 192 },
-+	{ 3, 256 },
-+	{ 4, 384 },
-+	{ 5, 512 },
-+	{ 6, 768 },
-+};
++static const struct snd_kcontrol_new le89156_snd_controls[] = {
 +
-+static unsigned int rates_11289[] = {
-+	44100, 88235,
-+};
++SOC_SINGLE("Digital Loopback Switch", LE89156_COMP, 0, 1, 0),
 +
-+static struct snd_pcm_hw_constraint_list constraints_11289 = {
-+	.count	= ARRAY_SIZE(rates_11289),
-+	.list	= rates_11289,
-+};
++SOC_ENUM("DAC Companding", le89156_enum[1]),
++SOC_ENUM("ADC Companding", le89156_enum[0]),
 +
-+static unsigned int rates_12288[] = {
-+	32000, 48000, 96000,
-+};
++SOC_ENUM("Playback De-emphasis", le89156_enum[2]),
++SOC_SINGLE("DAC Inversion Switch", LE89156_DAC, 0, 1, 0),
 +
-+static struct snd_pcm_hw_constraint_list constraints_12288 = {
-+	.count	= ARRAY_SIZE(rates_12288),
-+	.list	= rates_12288,
-+};
++SOC_SINGLE("Master Playback Volume", LE89156_DACVOL, 0, 127, 0),
 +
-+static unsigned int rates_16384[] = {
-+	32000,
-+};
++SOC_SINGLE("High Pass Filter Switch", LE89156_ADC, 8, 1, 0),
++SOC_SINGLE("High Pass Cut Off", LE89156_ADC, 4, 7, 0),
++SOC_SINGLE("ADC Inversion Switch", LE89156_COMP, 0, 1, 0),
 +
-+static struct snd_pcm_hw_constraint_list constraints_16384 = {
-+	.count	= ARRAY_SIZE(rates_16384),
-+	.list	= rates_16384,
-+};
++SOC_SINGLE("Capture Volume", LE89156_ADCVOL,  0, 127, 0),
 +
-+static unsigned int rates_16934[] = {
-+	44100, 88235,
-+};
++SOC_SINGLE("DAC Playback Limiter Switch", LE89156_DACLIM1,  8, 1, 0),
++SOC_SINGLE("DAC Playback Limiter Decay", LE89156_DACLIM1,  4, 15, 0),
++SOC_SINGLE("DAC Playback Limiter Attack", LE89156_DACLIM1,  0, 15, 0),
 +
-+static struct snd_pcm_hw_constraint_list constraints_16934 = {
-+	.count	= ARRAY_SIZE(rates_16934),
-+	.list	= rates_16934,
-+};
++SOC_SINGLE("DAC Playback Limiter Threshold", LE89156_DACLIM2,  4, 7, 0),
++SOC_SINGLE("DAC Playback Limiter Boost", LE89156_DACLIM2,  0, 15, 0),
++
++SOC_SINGLE("ALC Enable Switch", LE89156_ALC1,  8, 1, 0),
++SOC_SINGLE("ALC Capture Max Gain", LE89156_ALC1,  3, 7, 0),
++SOC_SINGLE("ALC Capture Min Gain", LE89156_ALC1,  0, 7, 0),
++
++SOC_SINGLE("ALC Capture ZC Switch", LE89156_ALC2,  8, 1, 0),
++SOC_SINGLE("ALC Capture Hold", LE89156_ALC2,  4, 7, 0),
++SOC_SINGLE("ALC Capture Target", LE89156_ALC2,  0, 15, 0),
++
++SOC_ENUM("ALC Capture Mode", le89156_enum[3]),
++SOC_SINGLE("ALC Capture Decay", LE89156_ALC3,  4, 15, 0),
++SOC_SINGLE("ALC Capture Attack", LE89156_ALC3,  0, 15, 0),
 +
-+static unsigned int rates_18432[] = {
-+	48000, 96000,
++SOC_SINGLE("ALC Capture Noise Gate Switch", LE89156_NGATE,  3, 1, 0),
++SOC_SINGLE("ALC Capture Noise Gate Threshold", LE89156_NGATE,  0, 7, 0),
++
++SOC_SINGLE("Capture PGA ZC Switch", LE89156_INPPGA,  7, 1, 0),
++SOC_SINGLE("Capture PGA Volume", LE89156_INPPGA,  0, 63, 0),
++
++SOC_SINGLE("Speaker Playback ZC Switch", LE89156_SPKVOL,  7, 1, 0),
++SOC_SINGLE("Speaker Playback Switch", LE89156_SPKVOL,  6, 1, 1),
++SOC_SINGLE("Speaker Playback Volume", LE89156_SPKVOL,  0, 63, 0),
++SOC_SINGLE("Speaker Boost", LE89156_OUTPUT, 2, 1, 0),
++
++SOC_SINGLE("Capture Boost(+20dB)", LE89156_ADCBOOST,  8, 1, 0),
++SOC_SINGLE("Mono Playback Switch", LE89156_MONOMIX, 6, 1, 1),
 +};
 +
-+static struct snd_pcm_hw_constraint_list constraints_18432 = {
-+	.count	= ARRAY_SIZE(rates_18432),
-+	.list	= rates_18432,
++/* Speaker Output Mixer */
++static const struct snd_kcontrol_new le89156_speaker_mixer_controls[] = {
++SOC_DAPM_SINGLE("Line Bypass Switch", LE89156_SPKMIX, 1, 1, 0),
++SOC_DAPM_SINGLE("Aux Playback Switch", LE89156_SPKMIX, 5, 1, 0),
++SOC_DAPM_SINGLE("PCM Playback Switch", LE89156_SPKMIX, 0, 1, 0),
 +};
 +
-+static unsigned int rates_22579[] = {
-+	44100, 88235, 1764000
++/* Mono Output Mixer */
++static const struct snd_kcontrol_new le89156_mono_mixer_controls[] = {
++SOC_DAPM_SINGLE("Line Bypass Switch", LE89156_MONOMIX, 1, 1, 0),
++SOC_DAPM_SINGLE("Aux Playback Switch", LE89156_MONOMIX, 2, 1, 0),
++SOC_DAPM_SINGLE("PCM Playback Switch", LE89156_MONOMIX, 0, 1, 0),
 +};
 +
-+static struct snd_pcm_hw_constraint_list constraints_22579 = {
-+	.count	= ARRAY_SIZE(rates_22579),
-+	.list	= rates_22579,
++static const struct snd_kcontrol_new le89156_boost_controls[] = {
++SOC_DAPM_SINGLE("Mic PGA Switch", LE89156_INPPGA,  6, 1, 1),
++SOC_DAPM_SINGLE("Aux Volume", LE89156_ADCBOOST, 0, 7, 0),
++SOC_DAPM_SINGLE("Mic Volume", LE89156_ADCBOOST, 4, 7, 0),
 +};
 +
-+static unsigned int rates_24576[] = {
-+	32000, 48000, 96000, 192000
++static const struct snd_kcontrol_new le89156_micpga_controls[] = {
++SOC_DAPM_SINGLE("MICP Switch", LE89156_INPUT, 0, 1, 0),
++SOC_DAPM_SINGLE("MICN Switch", LE89156_INPUT, 1, 1, 0),
++SOC_DAPM_SINGLE("AUX Switch", LE89156_INPUT, 2, 1, 0),
 +};
 +
-+static struct snd_pcm_hw_constraint_list constraints_24576 = {
-+	.count	= ARRAY_SIZE(rates_24576),
-+	.list	= rates_24576,
++static const struct snd_soc_dapm_widget le89156_dapm_widgets[] = {
++SND_SOC_DAPM_MIXER("Speaker Mixer", LE89156_POWER3, 2, 0,
++	&le89156_speaker_mixer_controls[0],
++	ARRAY_SIZE(le89156_speaker_mixer_controls)),
++SND_SOC_DAPM_MIXER("Mono Mixer", LE89156_POWER3, 3, 0,
++	&le89156_mono_mixer_controls[0],
++	ARRAY_SIZE(le89156_mono_mixer_controls)),
++SND_SOC_DAPM_DAC("DAC", "HiFi Playback", LE89156_POWER3, 0, 0),
++SND_SOC_DAPM_ADC("ADC", "HiFi Capture", LE89156_POWER2, 0, 0),
++SND_SOC_DAPM_PGA("Aux Input", LE89156_POWER1, 6, 0, NULL, 0),
++SND_SOC_DAPM_PGA("SpkN Out", LE89156_POWER3, 5, 0, NULL, 0),
++SND_SOC_DAPM_PGA("SpkP Out", LE89156_POWER3, 6, 0, NULL, 0),
++SND_SOC_DAPM_PGA("Mono Out", LE89156_POWER3, 7, 0, NULL, 0),
++
++SND_SOC_DAPM_MIXER("Mic PGA", LE89156_POWER2, 2, 0,
++		   &le89156_micpga_controls[0],
++		   ARRAY_SIZE(le89156_micpga_controls)),
++SND_SOC_DAPM_MIXER("Boost Mixer", LE89156_POWER2, 4, 0,
++	&le89156_boost_controls[0],
++	ARRAY_SIZE(le89156_boost_controls)),
++
++SND_SOC_DAPM_MICBIAS("Mic Bias", LE89156_POWER1, 4, 0),
++
++SND_SOC_DAPM_INPUT("MICN"),
++SND_SOC_DAPM_INPUT("MICP"),
++SND_SOC_DAPM_INPUT("AUX"),
++SND_SOC_DAPM_OUTPUT("MONOOUT"),
++SND_SOC_DAPM_OUTPUT("SPKOUTP"),
++SND_SOC_DAPM_OUTPUT("SPKOUTN"),
 +};
 +
-+static unsigned int rates_36864[] = {
-+	48000, 96000, 19200
++static const struct snd_soc_dapm_route le89156_dapm_routes[] = {
++	/* Mono output mixer */
++	{"Mono Mixer", "PCM Playback Switch", "DAC"},
++	{"Mono Mixer", "Aux Playback Switch", "Aux Input"},
++	{"Mono Mixer", "Line Bypass Switch", "Boost Mixer"},
++
++	/* Speaker output mixer */
++	{"Speaker Mixer", "PCM Playback Switch", "DAC"},
++	{"Speaker Mixer", "Aux Playback Switch", "Aux Input"},
++	{"Speaker Mixer", "Line Bypass Switch", "Boost Mixer"},
++
++	/* Outputs */
++	{"Mono Out", NULL, "Mono Mixer"},
++	{"MONOOUT", NULL, "Mono Out"},
++	{"SpkN Out", NULL, "Speaker Mixer"},
++	{"SpkP Out", NULL, "Speaker Mixer"},
++	{"SPKOUTN", NULL, "SpkN Out"},
++	{"SPKOUTP", NULL, "SpkP Out"},
++
++	/* Microphone PGA */
++	{"Mic PGA", "MICN Switch", "MICN"},
++	{"Mic PGA", "MICP Switch", "MICP"},
++	{ "Mic PGA", "AUX Switch", "Aux Input" },
++
++	/* Boost Mixer */
++	{"Boost Mixer", "Mic PGA Switch", "Mic PGA"},
++	{"Boost Mixer", "Mic Volume", "MICP"},
++	{"Boost Mixer", "Aux Volume", "Aux Input"},
++
++	{"ADC", NULL, "Boost Mixer"},
 +};
 +
-+static struct snd_pcm_hw_constraint_list constraints_36864 = {
-+	.count	= ARRAY_SIZE(rates_36864),
-+	.list	= rates_36864,
++struct pll_ {
++	unsigned int pre_div:4; /* prescale - 1 */
++	unsigned int n:4;
++	unsigned int k;
 +};
 +
++static struct pll_ pll_div;
++
++/* The size in bits of the pll divide multiplied by 10
++ * to allow rounding later */
++#define FIXED_PLL_SIZE ((1 << 24) * 10)
 +
-+static int le89156_startup(struct snd_pcm_substream *substream,
-+			  struct snd_soc_dai *dai)
++static void pll_factors(unsigned int target, unsigned int source)
 +{
-+	struct snd_soc_codec *codec = dai->codec;
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	unsigned long long Kpart;
++	unsigned int K, Ndiv, Nmod;
 +
-+	/* The set of sample rates that can be supported depends on the
-+	 * MCLK supplied to the CODEC - enforce this.
-+	 */
-+	if (!le89156->sysclk) {
-+		dev_err(codec->dev,
-+			"No MCLK configured, call set_sysclk() on init\n");
-+		return -EINVAL;
-+	}
++	Ndiv = target / source;
++	if (Ndiv < 6) {
++		source >>= 1;
++		pll_div.pre_div = 1;
++		Ndiv = target / source;
++	} else
++		pll_div.pre_div = 0;
 +
-+	snd_pcm_hw_constraint_list(substream->runtime, 0,
-+				   SNDRV_PCM_HW_PARAM_RATE,
-+				   le89156->sysclk_constraints);
++	if ((Ndiv < 6) || (Ndiv > 12))
++		printk(KERN_WARNING
++			"LE89156 N value %u outwith recommended range!d\n",
++			Ndiv);
 +
-+	return 0;
-+}
++	pll_div.n = Ndiv;
++	Nmod = target % source;
++	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
 +
-+static int le89156_hw_params(struct snd_pcm_substream *substream,
-+			    struct snd_pcm_hw_params *params,
-+			    struct snd_soc_dai *dai)
-+{
-+	struct snd_soc_codec *codec = dai->codec;
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	u16 iface = snd_soc_read(codec, LE89156_FORMAT_CONTROL) & 0x1FC;
-+	int i;
-+
-+	/* Find a supported LRCLK ratio */
-+	for (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {
-+		if (le89156->sysclk / params_rate(params) ==
-+		    lrclk_ratios[i].ratio)
-+			break;
-+	}
++	do_div(Kpart, source);
 +
-+	/* Should never happen, should be handled by constraints */
-+	if (i == ARRAY_SIZE(lrclk_ratios)) {
-+		dev_err(codec->dev, "MCLK/fs ratio %d unsupported\n",
-+			le89156->sysclk / params_rate(params));
-+		return -EINVAL;
-+	}
++	K = Kpart & 0xFFFFFFFF;
 +
-+	/* bit size */
-+	switch (params_format(params)) {
-+	case SNDRV_PCM_FORMAT_S16_LE:
-+		break;
-+	case SNDRV_PCM_FORMAT_S20_3LE:
-+		iface |= 0x0001;
-+		break;
-+	case SNDRV_PCM_FORMAT_S24_LE:
-+		iface |= 0x0002;
-+		break;
-+	case SNDRV_PCM_FORMAT_S32_LE:
-+		iface |= 0x0003;
-+		break;
-+	default:
-+		dev_dbg(codec->dev, "le89156_hw_params:    Unsupported bit size param = %d",
-+			params_format(params));
-+		return -EINVAL;
-+	}
++	/* Check if we need to round */
++	if ((K % 10) >= 5)
++		K += 5;
 +
-+	dev_dbg(codec->dev, "le89156_hw_params:    bit size param = %d",
-+		params_format(params));
++	/* Move down to proper range now rounding is done */
++	K /= 10;
 +
-+	snd_soc_write(codec, LE89156_FORMAT_CONTROL, iface);
-+	return 0;
++	pll_div.k = K;
 +}
 +
-+static int le89156_set_dai_sysclk(struct snd_soc_dai *codec_dai,
-+		int clk_id, unsigned int freq, int dir)
++static int le89156_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
++		int source, unsigned int freq_in, unsigned int freq_out)
 +{
 +	struct snd_soc_codec *codec = codec_dai->codec;
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	u16 reg;
 +
-+	dev_dbg(codec->dev, "le89156_set_dai_sysclk info: freq=%dHz\n", freq);
++	if (freq_in == 0 || freq_out == 0) {
++		/* Clock CODEC directly from MCLK */
++		reg = snd_soc_read(codec, LE89156_CLOCK);
++		snd_soc_write(codec, LE89156_CLOCK, reg & 0x0ff);
 +
-+	switch (freq) {
-+	case 11289600:
-+		le89156->sysclk_constraints = &constraints_11289;
-+		le89156->sysclk = freq;
++		/* Turn off PLL */
++		reg = snd_soc_read(codec, LE89156_POWER1);
++		snd_soc_write(codec, LE89156_POWER1, reg & 0x1df);
 +		return 0;
++	}
 +
-+	case 12288000:
-+		le89156->sysclk_constraints = &constraints_12288;
-+		le89156->sysclk = freq;
-+		return 0;
++	pll_factors(freq_out*4, freq_in);
 +
-+	case 16384000:
-+		le89156->sysclk_constraints = &constraints_16384;
-+		le89156->sysclk = freq;
-+		return 0;
++	snd_soc_write(codec, LE89156_PLLN, (pll_div.pre_div << 4) | pll_div.n);
++	snd_soc_write(codec, LE89156_PLLK1, pll_div.k >> 18);
++	snd_soc_write(codec, LE89156_PLLK2, (pll_div.k >> 9) & 0x1ff);
++	snd_soc_write(codec, LE89156_PLLK3, pll_div.k & 0x1ff);
++	reg = snd_soc_read(codec, LE89156_POWER1);
++	snd_soc_write(codec, LE89156_POWER1, reg | 0x020);
 +
-+	case 16934400:
-+		le89156->sysclk_constraints = &constraints_16934;
-+		le89156->sysclk = freq;
-+		return 0;
-+
-+	case 18432000:
-+		le89156->sysclk_constraints = &constraints_18432;
-+		le89156->sysclk = freq;
-+		return 0;
++	/* Run CODEC from PLL instead of MCLK */
++	reg = snd_soc_read(codec, LE89156_CLOCK);
++	snd_soc_write(codec, LE89156_CLOCK, reg | 0x100);
 +
-+	case 22579200:
-+	case 33868800:
-+		le89156->sysclk_constraints = &constraints_22579;
-+		le89156->sysclk = freq;
-+		return 0;
++	return 0;
++}
 +
-+	case 24576000:
-+		le89156->sysclk_constraints = &constraints_24576;
-+		le89156->sysclk = freq;
-+		return 0;
++/*
++ * Configure LE89156 clock dividers.
++ */
++static int le89156_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
++		int div_id, int div)
++{
++	struct snd_soc_codec *codec = codec_dai->codec;
++	u16 reg;
 +
-+	case 36864000:
-+		le89156->sysclk_constraints = &constraints_36864;
-+		le89156->sysclk = freq;
-+		return 0;
++	switch (div_id) {
++	case LE89156_OPCLKDIV:
++		reg = snd_soc_read(codec, LE89156_GPIO) & 0x1cf;
++		snd_soc_write(codec, LE89156_GPIO, reg | div);
++		break;
++	case LE89156_MCLKDIV:
++		reg = snd_soc_read(codec, LE89156_CLOCK) & 0x11f;
++		snd_soc_write(codec, LE89156_CLOCK, reg | div);
++		break;
++	case LE89156_ADCCLK:
++		reg = snd_soc_read(codec, LE89156_ADC) & 0x1f7;
++		snd_soc_write(codec, LE89156_ADC, reg | div);
++		break;
++	case LE89156_DACCLK:
++		reg = snd_soc_read(codec, LE89156_DAC) & 0x1f7;
++		snd_soc_write(codec, LE89156_DAC, reg | div);
++		break;
++	case LE89156_BCLKDIV:
++		reg = snd_soc_read(codec, LE89156_CLOCK) & 0x1e3;
++		snd_soc_write(codec, LE89156_CLOCK, reg | div);
++		break;
++	default:
++		return -EINVAL;
 +	}
-+	return -EINVAL;
++
++	return 0;
 +}
 +
 +static int le89156_set_dai_fmt(struct snd_soc_dai *codec_dai,
 +		unsigned int fmt)
 +{
 +	struct snd_soc_codec *codec = codec_dai->codec;
-+	u16 iface = snd_soc_read(codec, LE89156_FORMAT_CONTROL) & 0x1C3;
++	u16 iface = 0;
++	u16 clk = snd_soc_read(codec, LE89156_CLOCK) & 0x1fe;
 +
-+	/* check master/slave audio interface */
++	/* set master/slave audio interface */
 +	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
++	case SND_SOC_DAIFMT_CBM_CFM:
++		clk |= 0x0001;
++		break;
 +	case SND_SOC_DAIFMT_CBS_CFS:
 +		break;
 +	default:
@@ -338,18 +406,15 @@
 +	/* interface format */
 +	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 +	case SND_SOC_DAIFMT_I2S:
-+		iface |= 0x0008;
++		iface |= 0x0010;
 +		break;
 +	case SND_SOC_DAIFMT_RIGHT_J:
 +		break;
 +	case SND_SOC_DAIFMT_LEFT_J:
-+		iface |= 0x0004;
++		iface |= 0x0008;
 +		break;
 +	case SND_SOC_DAIFMT_DSP_A:
-+		iface |= 0x000C;
-+		break;
-+	case SND_SOC_DAIFMT_DSP_B:
-+		iface |= 0x001C;
++		iface |= 0x00018;
 +		break;
 +	default:
 +		return -EINVAL;
@@ -360,121 +425,201 @@
 +	case SND_SOC_DAIFMT_NB_NF:
 +		break;
 +	case SND_SOC_DAIFMT_IB_IF:
-+		iface |= 0x0010;
++		iface |= 0x0180;
 +		break;
 +	case SND_SOC_DAIFMT_IB_NF:
-+		iface |= 0x0020;
++		iface |= 0x0100;
 +		break;
 +	case SND_SOC_DAIFMT_NB_IF:
-+		iface |= 0x0030;
++		iface |= 0x0080;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
++	snd_soc_write(codec, LE89156_IFACE, iface);
++	snd_soc_write(codec, LE89156_CLOCK, clk);
++	return 0;
++}
 +
-+	dev_dbg(codec->dev, "le89156_set_dai_fmt:    Format=%x, Clock Inv=%x\n",
-+				fmt & SND_SOC_DAIFMT_FORMAT_MASK,
-+				((fmt & SND_SOC_DAIFMT_INV_MASK)));
++static int le89156_pcm_hw_params(struct snd_pcm_substream *substream,
++				struct snd_pcm_hw_params *params,
++				struct snd_soc_dai *dai)
++{
++	struct snd_soc_codec *codec = dai->codec;
++	u16 iface = snd_soc_read(codec, LE89156_IFACE) & 0x19f;
++	u16 adn = snd_soc_read(codec, LE89156_ADD) & 0x1f1;
 +
-+	snd_soc_write(codec, LE89156_FORMAT_CONTROL, iface);
++	/* bit size */
++	switch (params_format(params)) {
++	case SNDRV_PCM_FORMAT_S16_LE:
++		break;
++	case SNDRV_PCM_FORMAT_S20_3LE:
++		iface |= 0x0020;
++		break;
++	case SNDRV_PCM_FORMAT_S24_LE:
++		iface |= 0x0040;
++		break;
++	case SNDRV_PCM_FORMAT_S32_LE:
++		iface |= 0x0060;
++		break;
++	}
++
++	/* filter coefficient */
++	switch (params_rate(params)) {
++	case 8000:
++		adn |= 0x5 << 1;
++		break;
++	case 11025:
++		adn |= 0x4 << 1;
++		break;
++	case 16000:
++		adn |= 0x3 << 1;
++		break;
++	case 22050:
++		adn |= 0x2 << 1;
++		break;
++	case 32000:
++		adn |= 0x1 << 1;
++		break;
++	case 44100:
++	case 48000:
++		break;
++	}
++
++	snd_soc_write(codec, LE89156_IFACE, iface);
++	snd_soc_write(codec, LE89156_ADD, adn);
 +	return 0;
 +}
 +
-+#define LE89156_RATES (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
-+			SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
-+			SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \
-+			SNDRV_PCM_RATE_192000)
++static int le89156_mute(struct snd_soc_dai *dai, int mute)
++{
++	struct snd_soc_codec *codec = dai->codec;
++	u16 mute_reg = snd_soc_read(codec, LE89156_DAC) & 0xffbf;
++
++	if (mute)
++		snd_soc_write(codec, LE89156_DAC, mute_reg | 0x40);
++	else
++		snd_soc_write(codec, LE89156_DAC, mute_reg);
++	return 0;
++}
++
++/* liam need to make this lower power with dapm */
++static int le89156_set_bias_level(struct snd_soc_codec *codec,
++	enum snd_soc_bias_level level)
++{
++	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
++	u16 power1 = snd_soc_read(codec, LE89156_POWER1) & ~0x3;
++
++	switch (level) {
++	case SND_SOC_BIAS_ON:
++	case SND_SOC_BIAS_PREPARE:
++		power1 |= 0x1;  /* VMID 50k */
++		snd_soc_write(codec, LE89156_POWER1, power1);
++		break;
++
++	case SND_SOC_BIAS_STANDBY:
++		power1 |= LE89156_POWER1_BIASEN | LE89156_POWER1_BUFIOEN;
++
++		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
++			regcache_sync(le89156->regmap);
++
++			/* Initial cap charge at VMID 5k */
++			snd_soc_write(codec, LE89156_POWER1, power1 | 0x3);
++			mdelay(100);
++		}
++
++		power1 |= 0x2;  /* VMID 500k */
++		snd_soc_write(codec, LE89156_POWER1, power1);
++		break;
++
++	case SND_SOC_BIAS_OFF:
++		snd_soc_write(codec, LE89156_POWER1, 0);
++		snd_soc_write(codec, LE89156_POWER2, 0);
++		snd_soc_write(codec, LE89156_POWER3, 0);
++		break;
++	}
++
++	codec->dapm.bias_level = level;
++	return 0;
++}
++
++#define LE89156_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
++		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
++		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
 +
 +#define LE89156_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
-+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
++	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 +
 +static const struct snd_soc_dai_ops le89156_dai_ops = {
-+	.startup	= le89156_startup,
-+	.hw_params	= le89156_hw_params,
-+	.set_sysclk	= le89156_set_dai_sysclk,
++	.hw_params	= le89156_pcm_hw_params,
++	.digital_mute	= le89156_mute,
 +	.set_fmt	= le89156_set_dai_fmt,
++	.set_clkdiv	= le89156_set_dai_clkdiv,
++	.set_pll	= le89156_set_dai_pll,
 +};
 +
 +static struct snd_soc_dai_driver le89156_dai = {
-+	.name = "le89156",
++	.name = "le89156-hifi",
 +	.playback = {
 +		.stream_name = "Playback",
-+		.channels_min = 2,  /* Mono modes not yet supported */
++		.channels_min = 2,
 +		.channels_max = 2,
 +		.rates = LE89156_RATES,
-+		.formats = LE89156_FORMATS,
-+	},
++		.formats = LE89156_FORMATS,},
++	.capture = {
++		.stream_name = "Capture",
++		.channels_min = 2,
++		.channels_max = 2,
++		.rates = LE89156_RATES,
++		.formats = LE89156_FORMATS,},
 +	.ops = &le89156_dai_ops,
++	.symmetric_rates = 1,
 +};
 +
-+#ifdef CONFIG_PM
++static int le89156_suspend(struct snd_soc_codec *codec)
++{
++	le89156_set_bias_level(codec, SND_SOC_BIAS_OFF);
++	return 0;
++}
++
 +static int le89156_resume(struct snd_soc_codec *codec)
 +{
-+	snd_soc_cache_sync(codec);
++	le89156_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 +	return 0;
 +}
-+#else
-+#define le89156_suspend NULL
-+#define le89156_resume NULL
-+#endif
 +
 +static int le89156_probe(struct snd_soc_codec *codec)
 +{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+	int ret = 0;
-+
-+	ret = regulator_bulk_enable(ARRAY_SIZE(le89156->supplies),
-+				    le89156->supplies);
-+	if (ret != 0) {
-+		dev_err(codec->dev, "Failed to enable supplies: %d\n", ret);
-+		goto err_get;
-+	}
++	int ret;
 +
 +	ret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);
-+	if (ret != 0) {
-+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-+		goto err_enable;
-+	}
-+
-+	ret = le89156_reset(codec);
 +	if (ret < 0) {
-+		dev_err(codec->dev, "Failed to issue reset\n");
-+		goto err_enable;
++		printk(KERN_ERR "le89156: failed to set cache I/O: %d\n", ret);
++		return ret;
 +	}
 +
-+	/* Change some default settings - latch VU */
-+	snd_soc_update_bits(codec, LE89156_DACLLSB_ATTENUATION,
-+			    LE89156_UPDATELL, LE89156_UPDATELL);
-+	snd_soc_update_bits(codec, LE89156_DACLMSB_ATTENUATION,
-+			    LE89156_UPDATELM, LE89156_UPDATELM);
-+	snd_soc_update_bits(codec, LE89156_DACRLSB_ATTENUATION,
-+			    LE89156_UPDATERL, LE89156_UPDATERL);
-+	snd_soc_update_bits(codec, LE89156_DACRMSB_ATTENUATION,
-+			    LE89156_UPDATERM, LE89156_UPDATERM);
-+
-+	dev_dbg(codec->dev, "Successful registration\n");
-+	return ret;
++	le89156_reset(codec);
++
++	/* power on device */
++	le89156_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 +
-+err_enable:
-+	regulator_bulk_disable(ARRAY_SIZE(le89156->supplies), le89156->supplies);
-+err_get:
 +	return ret;
 +}
 +
++/* power down chip */
 +static int le89156_remove(struct snd_soc_codec *codec)
 +{
-+	struct le89156_priv *le89156 = snd_soc_codec_get_drvdata(codec);
-+
-+	regulator_bulk_disable(ARRAY_SIZE(le89156->supplies), le89156->supplies);
-+
++	le89156_set_bias_level(codec, SND_SOC_BIAS_OFF);
 +	return 0;
 +}
 +
 +static struct snd_soc_codec_driver soc_codec_dev_le89156 = {
 +	.probe =	le89156_probe,
 +	.remove =	le89156_remove,
++	.suspend =	le89156_suspend,
 +	.resume =	le89156_resume,
++	.set_bias_level = le89156_set_bias_level,
 +
 +	.controls = le89156_snd_controls,
 +	.num_controls = ARRAY_SIZE(le89156_snd_controls),
@@ -485,54 +630,41 @@
 +};
 +
 +static const struct of_device_id le89156_of_match[] = {
-+	{ .compatible = "zarlink,le89156", },
-+	{ }
++	{ .compatible = "zarlink,le89156" },
++	{ },
 +};
-+MODULE_DEVICE_TABLE(of, le89156_of_match);
 +
 +static const struct regmap_config le89156_regmap = {
 +	.reg_bits = 7,
 +	.val_bits = 9,
-+	.max_register = LE89156_MAX_REGISTER,
++	.max_register = LE89156_MONOMIX,
 +
 +	.reg_defaults = le89156_reg_defaults,
 +	.num_reg_defaults = ARRAY_SIZE(le89156_reg_defaults),
 +	.cache_type = REGCACHE_RBTREE,
 +
-+	.readable_reg = le89156_readable,
++	.volatile_reg = le89156_volatile,
 +};
 +
 +static int le89156_spi_probe(struct spi_device *spi)
 +{
 +	struct le89156_priv *le89156;
-+	int ret, i;
++	int ret;
 +
 +	le89156 = devm_kzalloc(&spi->dev, sizeof(struct le89156_priv),
-+			     GFP_KERNEL);
++			      GFP_KERNEL);
 +	if (le89156 == NULL)
 +		return -ENOMEM;
 +
-+	for (i = 0; i < ARRAY_SIZE(le89156->supplies); i++)
-+		le89156->supplies[i].supply = le89156_supply_names[i];
-+
-+	ret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(le89156->supplies),
-+				      le89156->supplies);
-+	if (ret != 0) {
-+		dev_err(&spi->dev, "Failed to request supplies: %d\n", ret);
-+		return ret;
-+	}
-+
 +	le89156->regmap = devm_regmap_init_spi(spi, &le89156_regmap);
-+	if (IS_ERR(le89156->regmap)) {
-+		ret = PTR_ERR(le89156->regmap);
-+		dev_err(&spi->dev, "Failed to init regmap: %d\n", ret);
-+		return ret;
-+	}
++	if (IS_ERR(le89156->regmap))
++		return PTR_ERR(le89156->regmap);
 +
 +	spi_set_drvdata(spi, le89156);
 +
 +	ret = snd_soc_register_codec(&spi->dev,
 +			&soc_codec_dev_le89156, &le89156_dai, 1);
++
 +	return ret;
 +}
 +
@@ -555,13 +687,11 @@
 +static int __init le89156_modinit(void)
 +{
 +	int ret = 0;
-+
 +	ret = spi_register_driver(&le89156_spi_driver);
 +	if (ret != 0) {
-+		printk(KERN_ERR "Failed to register le89156 SPI driver: %d\n",
++		printk(KERN_ERR "Failed to register LE89156 SPI driver: %d\n",
 +		       ret);
 +	}
-+
 +	return ret;
 +}
 +module_init(le89156_modinit);
@@ -573,19 +703,13 @@
 +module_exit(le89156_exit);
 +
 +MODULE_DESCRIPTION("ASoC LE89156 driver");
-+MODULE_AUTHOR("Ian Lartey <ian@opensource.wolfsonmicro.com>");
++MODULE_AUTHOR("Liam Girdwood");
 +MODULE_LICENSE("GPL");
 --- /dev/null
 +++ b/sound/soc/codecs/le89156.h
-@@ -0,0 +1,211 @@
+@@ -0,0 +1,102 @@
 +/*
-+ * le89156.h  --  WM8423 ASoC driver
-+ *
-+ * Copyright 2010 Wolfson Microelectronics, plc
-+ *
-+ * Author: Ian Lartey <ian@opensource.wolfsonmicro.com>
-+ *
-+ * Based on wm8753.h
++ * le89156.h  --  LE89156 Soc Audio driver
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
@@ -595,198 +719,95 @@
 +#ifndef _LE89156_H
 +#define _LE89156_H
 +
-+/*
-+ * Register values.
-+ */
-+#define LE89156_DACLLSB_ATTENUATION              0x00
-+#define LE89156_DACLMSB_ATTENUATION              0x01
-+#define LE89156_DACRLSB_ATTENUATION              0x02
-+#define LE89156_DACRMSB_ATTENUATION              0x03
-+#define LE89156_VOLUME_CONTROL                   0x04
-+#define LE89156_FORMAT_CONTROL                   0x05
-+#define LE89156_FILTER_CONTROL                   0x06
-+#define LE89156_MODE_CONTROL_1                   0x07
-+#define LE89156_MODE_CONTROL_2                   0x08
-+#define LE89156_RESET                            0x09
-+#define LE89156_ADDITIONAL_CONTROL_1             0x20
-+
-+#define LE89156_REGISTER_COUNT                   11
-+#define LE89156_MAX_REGISTER                     0x20
-+
-+/*
-+ * Field Definitions.
-+ */
-+
-+/*
-+ * R0 (0x00) - DACLLSB_ATTENUATION
-+ */
-+#define LE89156_UPDATELL                         0x0020  /* UPDATELL */
-+#define LE89156_UPDATELL_MASK                    0x0020  /* UPDATELL */
-+#define LE89156_UPDATELL_SHIFT                        5  /* UPDATELL */
-+#define LE89156_UPDATELL_WIDTH                        1  /* UPDATELL */
-+#define LE89156_LAT_4_0_MASK                     0x001F  /* LAT[4:0] - [4:0] */
-+#define LE89156_LAT_4_0_SHIFT                         0  /* LAT[4:0] - [4:0] */
-+#define LE89156_LAT_4_0_WIDTH                         5  /* LAT[4:0] - [4:0] */
-+
-+/*
-+ * R1 (0x01) - DACLMSB_ATTENUATION
-+ */
-+#define LE89156_UPDATELM                         0x0020  /* UPDATELM */
-+#define LE89156_UPDATELM_MASK                    0x0020  /* UPDATELM */
-+#define LE89156_UPDATELM_SHIFT                        5  /* UPDATELM */
-+#define LE89156_UPDATELM_WIDTH                        1  /* UPDATELM */
-+#define LE89156_LAT_9_5_0_MASK                   0x001F  /* LAT[9:5] - [4:0] */
-+#define LE89156_LAT_9_5_0_SHIFT                       0  /* LAT[9:5] - [4:0] */
-+#define LE89156_LAT_9_5_0_WIDTH                       5  /* LAT[9:5] - [4:0] */
-+
-+/*
-+ * R2 (0x02) - DACRLSB_ATTENUATION
-+ */
-+#define LE89156_UPDATERL                         0x0020  /* UPDATERL */
-+#define LE89156_UPDATERL_MASK                    0x0020  /* UPDATERL */
-+#define LE89156_UPDATERL_SHIFT                        5  /* UPDATERL */
-+#define LE89156_UPDATERL_WIDTH                        1  /* UPDATERL */
-+#define LE89156_RAT_4_0_MASK                     0x001F  /* RAT[4:0] - [4:0] */
-+#define LE89156_RAT_4_0_SHIFT                         0  /* RAT[4:0] - [4:0] */
-+#define LE89156_RAT_4_0_WIDTH                         5  /* RAT[4:0] - [4:0] */
-+
-+/*
-+ * R3 (0x03) - DACRMSB_ATTENUATION
-+ */
-+#define LE89156_UPDATERM                         0x0020  /* UPDATERM */
-+#define LE89156_UPDATERM_MASK                    0x0020  /* UPDATERM */
-+#define LE89156_UPDATERM_SHIFT                        5  /* UPDATERM */
-+#define LE89156_UPDATERM_WIDTH                        1  /* UPDATERM */
-+#define LE89156_RAT_9_5_0_MASK                   0x001F  /* RAT[9:5] - [4:0] */
-+#define LE89156_RAT_9_5_0_SHIFT                       0  /* RAT[9:5] - [4:0] */
-+#define LE89156_RAT_9_5_0_WIDTH                       5  /* RAT[9:5] - [4:0] */
-+
-+/*
-+ * R4 (0x04) - VOLUME_CONTROL
-+ */
-+#define LE89156_AMUTE                            0x0080  /* AMUTE */
-+#define LE89156_AMUTE_MASK                       0x0080  /* AMUTE */
-+#define LE89156_AMUTE_SHIFT                           7  /* AMUTE */
-+#define LE89156_AMUTE_WIDTH                           1  /* AMUTE */
-+#define LE89156_ZFLAG_MASK                       0x0060  /* ZFLAG - [6:5] */
-+#define LE89156_ZFLAG_SHIFT                           5  /* ZFLAG - [6:5] */
-+#define LE89156_ZFLAG_WIDTH                           2  /* ZFLAG - [6:5] */
-+#define LE89156_IZD                              0x0010  /* IZD */
-+#define LE89156_IZD_MASK                         0x0010  /* IZD */
-+#define LE89156_IZD_SHIFT                             4  /* IZD */
-+#define LE89156_IZD_WIDTH                             1  /* IZD */
-+#define LE89156_SOFT                             0x0008  /* SOFT MUTE */
-+#define LE89156_SOFT_MASK                        0x0008  /* SOFT MUTE */
-+#define LE89156_SOFT_SHIFT                            3  /* SOFT MUTE */
-+#define LE89156_SOFT_WIDTH                            1  /* SOFT MUTE */
-+#define LE89156_ATC                              0x0004  /* ATC */
-+#define LE89156_ATC_MASK                         0x0004  /* ATC */
-+#define LE89156_ATC_SHIFT                             2  /* ATC */
-+#define LE89156_ATC_WIDTH                             1  /* ATC */
-+#define LE89156_ATT2DB                           0x0002  /* ATT2DB */
-+#define LE89156_ATT2DB_MASK                      0x0002  /* ATT2DB */
-+#define LE89156_ATT2DB_SHIFT                          1  /* ATT2DB */
-+#define LE89156_ATT2DB_WIDTH                          1  /* ATT2DB */
-+#define LE89156_VOL_RAMP                         0x0001  /* VOL_RAMP */
-+#define LE89156_VOL_RAMP_MASK                    0x0001  /* VOL_RAMP */
-+#define LE89156_VOL_RAMP_SHIFT                        0  /* VOL_RAMP */
-+#define LE89156_VOL_RAMP_WIDTH                        1  /* VOL_RAMP */
-+
-+/*
-+ * R5 (0x05) - FORMAT_CONTROL
-+ */
-+#define LE89156_PWDN                             0x0080  /* PWDN */
-+#define LE89156_PWDN_MASK                        0x0080  /* PWDN */
-+#define LE89156_PWDN_SHIFT                            7  /* PWDN */
-+#define LE89156_PWDN_WIDTH                            1  /* PWDN */
-+#define LE89156_REV                              0x0040  /* REV */
-+#define LE89156_REV_MASK                         0x0040  /* REV */
-+#define LE89156_REV_SHIFT                             6  /* REV */
-+#define LE89156_REV_WIDTH                             1  /* REV */
-+#define LE89156_BCP                              0x0020  /* BCP */
-+#define LE89156_BCP_MASK                         0x0020  /* BCP */
-+#define LE89156_BCP_SHIFT                             5  /* BCP */
-+#define LE89156_BCP_WIDTH                             1  /* BCP */
-+#define LE89156_LRP                              0x0010  /* LRP */
-+#define LE89156_LRP_MASK                         0x0010  /* LRP */
-+#define LE89156_LRP_SHIFT                             4  /* LRP */
-+#define LE89156_LRP_WIDTH                             1  /* LRP */
-+#define LE89156_FMT_MASK                         0x000C  /* FMT - [3:2] */
-+#define LE89156_FMT_SHIFT                             2  /* FMT - [3:2] */
-+#define LE89156_FMT_WIDTH                             2  /* FMT - [3:2] */
-+#define LE89156_IWL_MASK                         0x0003  /* IWL - [1:0] */
-+#define LE89156_IWL_SHIFT                             0  /* IWL - [1:0] */
-+#define LE89156_IWL_WIDTH                             2  /* IWL - [1:0] */
-+
-+/*
-+ * R6 (0x06) - FILTER_CONTROL
-+ */
-+#define LE89156_ZFLAG_HI                         0x0080  /* ZFLAG_HI */
-+#define LE89156_ZFLAG_HI_MASK                    0x0080  /* ZFLAG_HI */
-+#define LE89156_ZFLAG_HI_SHIFT                        7  /* ZFLAG_HI */
-+#define LE89156_ZFLAG_HI_WIDTH                        1  /* ZFLAG_HI */
-+#define LE89156_DEEMPH_MASK                      0x0060  /* DEEMPH - [6:5] */
-+#define LE89156_DEEMPH_SHIFT                          5  /* DEEMPH - [6:5] */
-+#define LE89156_DEEMPH_WIDTH                          2  /* DEEMPH - [6:5] */
-+#define LE89156_DSDFILT_MASK                     0x0018  /* DSDFILT - [4:3] */
-+#define LE89156_DSDFILT_SHIFT                         3  /* DSDFILT - [4:3] */
-+#define LE89156_DSDFILT_WIDTH                         2  /* DSDFILT - [4:3] */
-+#define LE89156_FIRSEL_MASK                      0x0007  /* FIRSEL - [2:0] */
-+#define LE89156_FIRSEL_SHIFT                          0  /* FIRSEL - [2:0] */
-+#define LE89156_FIRSEL_WIDTH                          3  /* FIRSEL - [2:0] */
-+
-+/*
-+ * R7 (0x07) - MODE_CONTROL_1
-+ */
-+#define LE89156_MODE8X                           0x0080  /* MODE8X */
-+#define LE89156_MODE8X_MASK                      0x0080  /* MODE8X */
-+#define LE89156_MODE8X_SHIFT                          7  /* MODE8X */
-+#define LE89156_MODE8X_WIDTH                          1  /* MODE8X */
-+#define LE89156_OSR_MASK                         0x0060  /* OSR - [6:5] */
-+#define LE89156_OSR_SHIFT                             5  /* OSR - [6:5] */
-+#define LE89156_OSR_WIDTH                             2  /* OSR - [6:5] */
-+#define LE89156_SR_MASK                          0x001C  /* SR - [4:2] */
-+#define LE89156_SR_SHIFT                              2  /* SR - [4:2] */
-+#define LE89156_SR_WIDTH                              3  /* SR - [4:2] */
-+#define LE89156_MODESEL_MASK                     0x0003  /* MODESEL - [1:0] */
-+#define LE89156_MODESEL_SHIFT                         0  /* MODESEL - [1:0] */
-+#define LE89156_MODESEL_WIDTH                         2  /* MODESEL - [1:0] */
-+
-+/*
-+ * R8 (0x08) - MODE_CONTROL_2
-+ */
-+#define LE89156_DSD_GAIN                         0x0040  /* DSD_GAIN */
-+#define LE89156_DSD_GAIN_MASK                    0x0040  /* DSD_GAIN */
-+#define LE89156_DSD_GAIN_SHIFT                        6  /* DSD_GAIN */
-+#define LE89156_DSD_GAIN_WIDTH                        1  /* DSD_GAIN */
-+#define LE89156_SDOUT                            0x0020  /* SDOUT */
-+#define LE89156_SDOUT_MASK                       0x0020  /* SDOUT */
-+#define LE89156_SDOUT_SHIFT                           5  /* SDOUT */
-+#define LE89156_SDOUT_WIDTH                           1  /* SDOUT */
-+#define LE89156_DOUT                             0x0010  /* DOUT */
-+#define LE89156_DOUT_MASK                        0x0010  /* DOUT */
-+#define LE89156_DOUT_SHIFT                            4  /* DOUT */
-+#define LE89156_DOUT_WIDTH                            1  /* DOUT */
-+#define LE89156_DIFF_MASK                        0x000C  /* DIFF - [3:2] */
-+#define LE89156_DIFF_SHIFT                            2  /* DIFF - [3:2] */
-+#define LE89156_DIFF_WIDTH                            2  /* DIFF - [3:2] */
-+#define LE89156_DITHER_MASK                      0x0003  /* DITHER - [1:0] */
-+#define LE89156_DITHER_SHIFT                          0  /* DITHER - [1:0] */
-+#define LE89156_DITHER_WIDTH                          2  /* DITHER - [1:0] */
-+
-+/*
-+ * R32 (0x20) - ADDITONAL_CONTROL_1
-+ */
-+#define LE89156_DSD_LEVEL                        0x0002  /* DSD_LEVEL */
-+#define LE89156_DSD_LEVEL_MASK                   0x0002  /* DSD_LEVEL */
-+#define LE89156_DSD_LEVEL_SHIFT                       1  /* DSD_LEVEL */
-+#define LE89156_DSD_LEVEL_WIDTH                       1  /* DSD_LEVEL */
-+#define LE89156_DSD_NO_NOTCH                     0x0001  /* DSD_NO_NOTCH */
-+#define LE89156_DSD_NO_NOTCH_MASK                0x0001  /* DSD_NO_NOTCH */
-+#define LE89156_DSD_NO_NOTCH_SHIFT                    0  /* DSD_NO_NOTCH */
-+#define LE89156_DSD_NO_NOTCH_WIDTH                    1  /* DSD_NO_NOTCH */
-+
-+#define  LE89156_SYSCLK 0
++/* LE89156 register space */
++
++#define LE89156_RESET		0x0
++#define LE89156_POWER1		0x1
++#define LE89156_POWER2		0x2
++#define LE89156_POWER3		0x3
++#define LE89156_IFACE		0x4
++#define LE89156_COMP			0x5
++#define LE89156_CLOCK		0x6
++#define LE89156_ADD			0x7
++#define LE89156_GPIO			0x8
++#define LE89156_DAC			0xa
++#define LE89156_DACVOL		0xb
++#define LE89156_ADC			0xe
++#define LE89156_ADCVOL		0xf
++#define LE89156_EQ1			0x12
++#define LE89156_EQ2			0x13
++#define LE89156_EQ3			0x14
++#define LE89156_EQ4			0x15
++#define LE89156_EQ5			0x16
++#define LE89156_DACLIM1		0x18
++#define LE89156_DACLIM2		0x19
++#define LE89156_NOTCH1		0x1b
++#define LE89156_NOTCH2		0x1c
++#define LE89156_NOTCH3		0x1d
++#define LE89156_NOTCH4		0x1e
++#define LE89156_ALC1			0x20
++#define LE89156_ALC2			0x21
++#define LE89156_ALC3			0x22
++#define LE89156_NGATE		0x23
++#define LE89156_PLLN			0x24
++#define LE89156_PLLK1		0x25
++#define LE89156_PLLK2		0x26
++#define LE89156_PLLK3		0x27
++#define LE89156_ATTEN		0x28
++#define LE89156_INPUT		0x2c
++#define LE89156_INPPGA		0x2d
++#define LE89156_ADCBOOST		0x2f
++#define LE89156_OUTPUT		0x31
++#define LE89156_SPKMIX		0x32
++#define LE89156_SPKVOL		0x36
++#define LE89156_MONOMIX		0x38
++
++#define LE89156_CACHEREGNUM 	57
++
++/* Clock divider Id's */
++#define LE89156_OPCLKDIV		0
++#define LE89156_MCLKDIV		1
++#define LE89156_ADCCLK		2
++#define LE89156_DACCLK		3
++#define LE89156_BCLKDIV		4
++
++/* DAC clock dividers */
++#define LE89156_DACCLK_F2	(1 << 3)
++#define LE89156_DACCLK_F4	(0 << 3)
++
++/* ADC clock dividers */
++#define LE89156_ADCCLK_F2	(1 << 3)
++#define LE89156_ADCCLK_F4	(0 << 3)
++
++/* PLL Out dividers */
++#define LE89156_OPCLKDIV_1	(0 << 4)
++#define LE89156_OPCLKDIV_2	(1 << 4)
++#define LE89156_OPCLKDIV_3	(2 << 4)
++#define LE89156_OPCLKDIV_4	(3 << 4)
++
++/* BCLK clock dividers */
++#define LE89156_BCLKDIV_1	(0 << 2)
++#define LE89156_BCLKDIV_2	(1 << 2)
++#define LE89156_BCLKDIV_4	(2 << 2)
++#define LE89156_BCLKDIV_8	(3 << 2)
++#define LE89156_BCLKDIV_16	(4 << 2)
++#define LE89156_BCLKDIV_32	(5 << 2)
++
++/* MCLK clock dividers */
++#define LE89156_MCLKDIV_1	(0 << 5)
++#define LE89156_MCLKDIV_1_5	(1 << 5)
++#define LE89156_MCLKDIV_2	(2 << 5)
++#define LE89156_MCLKDIV_3	(3 << 5)
++#define LE89156_MCLKDIV_4	(4 << 5)
++#define LE89156_MCLKDIV_6	(5 << 5)
++#define LE89156_MCLKDIV_8	(6 << 5)
++#define LE89156_MCLKDIV_12	(7 << 5)
++
++struct le89156_setup_data {
++	int spi;
++	int i2c_bus;
++	unsigned short i2c_address;
++};
 +
 +#endif
 --- a/sound/soc/ralink/Kconfig
